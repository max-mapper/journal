<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sentence Explorer</title>
    <!-- PapaParse for fast CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
      :root {
        --primary: #2563eb;
        --primary-hover: #1d4ed8;
        --success: #16a34a;
        --warning: #f59e0b;
        --bg: #f8fafc;
        --surface: #ffffff;
        --border: #e2e8f0;
        --text: #1e293b;
        --highlight-bg: #e0f2fe;
        --highlight-text: #0369a1;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        background-color: var(--bg);
        color: var(--text);
        margin: 0;
        padding: 20px;
        line-height: 2.2;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      /* Header & Controls */
      header {
        background: var(--surface);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      h1 {
        margin: 0 0 15px 0;
        font-size: 1.5rem;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        align-items: flex-start;
      }
      .file-upload {
        border: 2px dashed var(--border);
        padding: 15px;
        border-radius: 6px;
        background: #f1f5f9;
        flex: 1;
        min-width: 250px;
      }
      .filters {
        display: flex;
        flex-direction: column;
        gap: 15px;
        flex: 3;
      }
      .filter-row {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        align-items: center;
      }

      .input-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .input-group input[type="text"] {
        padding: 6px 10px;
        border: 1px solid var(--border);
        border-radius: 4px;
        font-size: 1rem;
        width: 200px;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        font-weight: 500;
        user-select: none;
      }
      input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: var(--primary);
      }

      .actions {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        width: 100%;
        margin-top: 10px;
        gap: 10px;
      }

      button {
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        transition:
          background 0.2s,
          opacity 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .export-btn {
        background-color: var(--success);
        color: white;
      }
      .export-btn:hover {
        background-color: #15803d;
      }
      .sort-btn {
        background-color: var(--warning);
        color: white;
      }
      .sort-btn:hover {
        background-color: #d97706;
      }
      button:disabled {
        background-color: #94a3b8;
        cursor: not-allowed;
        opacity: 0.7;
      }

      /* Stats & Pagination */
      .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        background: var(--surface);
        padding: 12px 20px;
        border-radius: 8px;
        border: 1px solid var(--border);
        font-size: 0.95rem;
      }
      .pagination button {
        background: var(--primary);
        color: white;
      }
      .pagination button:hover {
        background: var(--primary-hover);
      }

      /* Table */
      .table-container {
        background: var(--surface);
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        overflow-x: auto;
        min-height: 400px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 18px;
        table-layout: fixed;
      }
      th,
      td {
        padding: 14px 18px;
        text-align: left;
        border-bottom: 1px solid var(--border);
        vertical-align: top;
      }
      th {
        background-color: #f8fafc;
        font-weight: 600;
        color: #475569;
        border-bottom: 2px solid var(--border);
      }
      tr:hover td {
        background-color: #f1f5f9;
      }

      /* Column Widths */
      .jp-col {
        width: 50%;
        border-right: 1px solid #f1f5f9;
      }
      .en-col {
        color: rgba(0, 0, 0, 0);
        width: 50%;
      }
      .en-col:hover {
        color: #334155;
      }

      ruby {
        ruby-position: over;
      }
      rt {
        font-size: 0.6em;
        color: rgba(0, 0, 0, 0); /* var(--ruby-color) */
        user-select: none;
      }
      ruby:hover rt,
      rt:hover {
        color: #64748b;
      }

      /* Ensure highlights play nicely with ruby */
      .highlighted-word {
        /* Existing styles... */
        /* background-color: var(--highlight-bg); */
        color: var(--highlight-text);
        /* border-bottom: 2px solid var(--primary); */
        /* border-radius: 4px; */
        /* padding: 0 2px; */
        cursor: help;
        transition: background 0.2s;
        /* Tweaks for ruby layout */
        display: inline-block;
        line-height: 1.8;
      }
      .highlighted-word:hover {
        font-weight: bold;
      }

      /* Tooltip Styling */
      #tooltip {
        position: fixed;
        display: none;
        background: #1e293b;
        color: #fff;
        padding: 12px;
        border-radius: 6px;
        font-size: 0.9rem;
        max-width: 320px;
        z-index: 2000;
        pointer-events: none; /* Allows mouse to move without flickering */
        box-shadow:
          0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        line-height: 1.5;
      }

      #tooltip .entry {
        margin-bottom: 1px;
        border-bottom: 1px solid #647080;
        padding-bottom: 1px;
      }
      #tooltip .entry:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      #tooltip i {
        color: #94a3b8;
        font-size: 0.85em;
      }

      #loading {
        display: none;
        color: var(--primary);
        font-weight: bold;
        margin-left: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Sentence Explorer</h1>
        <div class="controls">
          <div class="filters">
            <div class="file-upload">
              <input type="file" id="csvFile" accept=".csv, .txt, .tsv" />
              <span id="loading">Processing...</span>
            </div>
            <button class="sort-btn" onclick="app.loadExamples()">
              Load Example Sentences
            </button>
            <span class="status"></span>
          </div>
          <div class="filters">
            <div class="filter-row">
              <strong>Grade Filter:</strong>
              <label class="checkbox-group">
                <input
                  type="checkbox"
                  id="grade1"
                  onchange="app.applyFilters()"
                />
                1st Grade
              </label>
              <label class="checkbox-group">
                <input
                  type="checkbox"
                  id="grade2"
                  onchange="app.applyFilters()"
                />
                2nd Grade
              </label>
            </div>

            <div class="filter-row">
              <div class="input-group">
                <label
                  for="customKanji"
                  style="font-weight: bold; font-size: 0.9rem"
                  >Must include one of:</label
                >
                <input
                  type="text"
                  id="customKanji"
                  placeholder=""
                  oninput="app.applyFilters()"
                />
              </div>
            </div>

            <div class="filter-row">
              <strong>Options:</strong>
              <label class="checkbox-group">
                <input
                  type="checkbox"
                  id="requireKanji"
                  onchange="app.applyFilters()"
                />
                Only sentences with 1+ Kanji
              </label>
            </div>

            <div class="actions">
              <button
                class="sort-btn"
                id="sortBtn"
                onclick="app.sortByUsefulness()"
                disabled
              >
                <span>âš¡</span> Sort by Usefulness
              </button>
              <button
                class="export-btn"
                id="exportBtn"
                onclick="app.exportCSV()"
                disabled
              >
                <span>ðŸ“¥</span> Export Filtered CSV
              </button>
            </div>
          </div>
        </div>
      </header>

      <div class="status-bar">
        <div id="countDisplay">Rows: 0</div>
        <div class="pagination">
          <button id="prevBtn" onclick="app.changePage(-1)" disabled>
            Previous
          </button>
          <span id="pageDisplay" style="margin: 0 15px">Page 1 / 1</span>
          <button id="nextBtn" onclick="app.changePage(1)" disabled>
            Next
          </button>
        </div>
      </div>
      <!-- Inside the body container -->
      <div class="table-container">
        <table>
          <thead>
            <tr>
              <th class="jp-col">Japanese</th>
              <th class="en-col">English</th>
            </tr>
          </thead>
          <tbody id="tableBody">
            <tr>
              <td
                colspan="2"
                style="text-align: center; padding: 30px; color: #64748b"
              >
                Please upload a CSV file to begin.
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Tooltip Container -->
      <div id="tooltip"></div>
    </div>

    <script type="module">
      // --- Global Variables & Imports ---
      var MIN_LEN = 1;
      const KANJI_G1 =
        "ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒæ—¥æœˆç«æ°´æœ¨é‡‘åœŸå¹´å±±å·ç”°çŸ³ç©ºé›¨å¤©å¤•èŠ±è‰ç«¹æž—æ£®çŠ¬è™«è²äººç”·å¥³å­çŽ‹ç›®è€³å£æ‰‹è¶³åŠ›ä¸Šä¸‹å·¦å³ä¸­å¤§å°å††ç™½èµ¤é’æ­£æ—©æ°—å…¥å‡ºç«‹è¦‹ä¼‘ç”Ÿå…ˆå­¦æ ¡æ–‡å­—æœ¬åæ‘ç”ºè»Šç³¸çŽ‰éŸ³";
      const KANJI_G2 =
        "å¼•ç¾½é›²åœ’é ä½•ç§‘å¤å®¶æ­Œç”»å›žä¼šæµ·çµµå¤–è§’æ¥½æ´»é–“ä¸¸å²©é¡”æ±½è¨˜å¸°å¼“ç‰›é­šäº¬å¼·æ•™è¿‘å…„å½¢è¨ˆå…ƒè¨€åŽŸæˆ¸å¤åˆå¾Œèªžå·¥å…¬åºƒäº¤å…‰è€ƒè¡Œé«˜é»„åˆè°·å›½é»’ä»Šæ‰ç´°ä½œç®—æ­¢å¸‚çŸ¢å§‰æ€ç´™å¯ºè‡ªæ™‚å®¤ç¤¾å¼±é¦–ç§‹é€±æ˜¥æ›¸å°‘å ´è‰²é£Ÿå¿ƒæ–°è¦ªå›³æ•°è¥¿å£°æ˜Ÿæ™´åˆ‡é›ªèˆ¹ç·šå‰çµ„èµ°å¤šå¤ªä½“å°åœ°æ± çŸ¥èŒ¶æ˜¼é•·é³¥æœç›´é€šå¼Ÿåº—ç‚¹é›»åˆ€å†¬å½“æ±ç­”é ­åŒé“èª­å†…å—è‚‰é¦¬å£²è²·éº¦åŠç•ªçˆ¶é¢¨åˆ†èžç±³æ­©æ¯æ–¹åŒ—æ¯Žå¦¹ä¸‡æ˜Žé³´æ¯›é–€å¤œé‡Žå‹ç”¨æ›œæ¥é‡Œç†è©±";
      const kanjiRegex = /[\u4e00-\u9faf]/g;

      console.time("import");
      import {
        SudachiStateless,
        TokenizeMode,
      } from "./sudachi-wasm/sudachi.js";
      console.timeEnd("import");

      const statusEl = document.querySelector(".status");
      const tooltip = document.getElementById("tooltip");
      let db;

      // --- App State ---
      const state = (window.state = {
        allData: [],
        filteredIndices: [],
        currentPage: 1,
        sudachi: null,
        usefulnessMap: new Map(),
        isSortedByScore: false,
      });

      // --- Helpers: Dictionary & Parsing ---
      async function fetchAndGunzip(url) {
        const response = await fetch(url);
        if (!response.body) throw new Error("No response body");
        const ds = new DecompressionStream("gzip");
        const stream = response.body.pipeThrough(ds);
        return await new Response(stream).blob();
      }

      function isKanji(ch) {
        return (ch >= "\u4e00" && ch <= "\u9faf") || ch === "ã€…";
      }
      function isKana(char) {
        return /[\u3040-\u309f\u30a0-\u30ff\u30fc]/.test(char);
      }

      function katakanaToHiragana(input) {
        return input.replace(/[\u30a1-\u30f6]/g, function (match) {
          var code = match.charCodeAt(0) - 0x60;
          return String.fromCharCode(code);
        });
      }

      function generateRuby(surface, reading) {
        if (surface === reading) return surface;

        // Find matching suffix
        let sEnd = surface.length;
        let rEnd = reading.length;
        while (sEnd > 0 && rEnd > 0) {
          if (surface[sEnd - 1] === reading[rEnd - 1]) {
            sEnd--;
            rEnd--;
          } else break;
        }

        // Find matching prefix
        let sStart = 0;
        let rStart = 0;
        while (sStart < sEnd && rStart < rEnd) {
          if (surface[sStart] === reading[rStart]) {
            sStart++;
            rStart++;
          } else break;
        }

        const prefix = surface.substring(0, sStart);
        const suffix = surface.substring(sEnd);
        const coreSurface = surface.substring(sStart, sEnd);
        const coreReading = reading.substring(rStart, rEnd);

        // Don't ruby if core is empty or just kana
        if (!coreSurface) return surface;

        return `${prefix}<ruby>${coreSurface}<rt>${coreReading}</rt></ruby>${suffix}`;
      }

      async function searchDictionary(term) {
        if (!db) {
          tooltip.innerHTML = "Loading dictionary...";
          let blob = await fetchAndGunzip("jpdict.json.gz");
          db = JSON.parse(await blob.text());
        }

        let idx = db.index[term];
        if (!idx && term.length > 1) {
          let last = term[term.length - 1];
          let lastlast = term[term.length - 2];
          if (isKanji(lastlast) && isKana(last)) {
            idx = db.index[term.slice(0, term.length - 1)];
          }
        }
        if (!idx) return null;
        return db.defs[idx[0]];
      }

      // --- Sudachi Handling ---
      async function initSudachi() {
        try {
          statusEl.innerText = "Downloading dictionary...";
          let dictBlob = await fetchAndGunzip(
            "sudachi-wasm/resources/system.dic.gz",
          );
          const buffer = await dictBlob.arrayBuffer();
          const uint8Array = new Uint8Array(buffer);

          state.sudachi = new SudachiStateless();
          await state.sudachi.initialize_from_bytes(uint8Array);
          statusEl.innerText = "Dictionary loaded";
        } catch (err) {
          statusEl.innerText = "Dict error: " + err.message;
        }

        // Load Usefulness Data
        try {
          const response = await fetch("kanshudo-usefulness.json");
          const data = await response.json();
          if (data && data.usefulness) {
            data.usefulness.forEach((item) => {
              state.usefulnessMap.set(item.kanji, item.level);
            });
          }
        } catch (e) {
          console.error("Failed to load usefulness data", e);
        }
      }
      initSudachi();

      function sudachiParse(text) {
        if (!state.sudachi) return [];
        try {
          return JSON.parse(
            state.sudachi.tokenize_stringified(text, TokenizeMode.C),
          );
        } catch (err) {
          return [];
        }
      }

      // --- UI Elements ---
      const ui = {
        fileInput: document.getElementById("csvFile"),
        loadingMsg: document.getElementById("loading"),
        tableBody: document.getElementById("tableBody"),
        countDisplay: document.getElementById("countDisplay"),
        pageDisplay: document.getElementById("pageDisplay"),
        prevBtn: document.getElementById("prevBtn"),
        nextBtn: document.getElementById("nextBtn"),
        exportBtn: document.getElementById("exportBtn"),
        sortBtn: document.getElementById("sortBtn"),
        checkG1: document.getElementById("grade1"),
        checkG2: document.getElementById("grade2"),
        checkRequire: document.getElementById("requireKanji"),
        customKanjiInput: document.getElementById("customKanji"),
      };

      // --- Main Logic ---
      window.app = {
        applyFilters: () => {
          if (state.allData.length === 0) return;

          state.isSortedByScore = false; // Reset sort on filter change
          ui.sortBtn.innerHTML = `<span>âš¡</span> Sort by Usefulness`;

          const useG1 = ui.checkG1.checked;
          const useG2 = ui.checkG2.checked;
          const requireKanji = ui.checkRequire.checked;
          const customKanjiText = ui.customKanjiInput.value || "";

          // Build Allowed Set
          const allowedSet = new Set();
          if (useG1) KANJI_G1.split("").forEach((k) => allowedSet.add(k));
          if (useG2) KANJI_G2.split("").forEach((k) => allowedSet.add(k));

          const secondFilter = new Set();
          // Add Custom Kanji Input to allowed set
          for (const char of customKanjiText) {
            secondFilter.add(char);
          }

          const isFilteringGrades = useG1 || useG2;
          state.filteredIndices = [];

          for (let i = 0; i < state.allData.length; i++) {
            const row = state.allData[i];
            const kanjiCount = row.rowKanji.size;

            if (requireKanji && kanjiCount === 0) continue;

            if (!isFilteringGrades && !secondFilter.size) {
              state.filteredIndices.push(i);
              continue;
            }

            let isValid = true;
            if (kanjiCount > 0 && isFilteringGrades) {
              for (let k of row.rowKanji) {
                if (!allowedSet.has(k)) {
                  isValid = false;
                  break;
                }
              }
            }
            if (!isValid) continue;

            if (!secondFilter.size) {
              state.filteredIndices.push(i);
              continue;
            }

            let matchesOneOrMore = false;
            for (let k of row.rowKanji) {
              if (secondFilter.has(k)) {
                matchesOneOrMore = true;
              }
            }
            if (matchesOneOrMore) state.filteredIndices.push(i);
          }

          state.currentPage = 1;
          renderTable();
        },

        loadExamples: async () => {
          statusEl.innerText = "Downloading examples...";
          const blob = await fetchAndGunzip("iyaku-sentences.tsv.gz");
          const text = await blob.text();
          Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
            quoteChar: "",
            delimiter: "\t",
            complete: function (results) {
              processData(results.data);
              statusEl.innerText = "Examples loaded";
              ui.loadingMsg.style.display = "none";
              ui.exportBtn.disabled = false;
              ui.sortBtn.disabled = false;
            },
          });
        },

        sortByUsefulness: async () => {
          if (state.filteredIndices.length === 0) return;
          ui.loadingMsg.style.display = "inline";
          statusEl.innerText = "Analyzing usefulness...";
          ui.sortBtn.disabled = true;
          await new Promise((r) => setTimeout(r, 10));

          for (let i = 0; i < state.filteredIndices.length; i++) {
            const globalIndex = state.filteredIndices[i];
            const row = state.allData[globalIndex];
            // Calculate Score only (Parsing for display happens in renderTable)
            if (!row.usefulnessData) {
              const tokens = sudachiParse(row.jp);
              let totalInvertedLevel = 0;
              tokens.forEach((t) => {
                let level =
                  state.usefulnessMap.get(t.dictionary_form) ||
                  state.usefulnessMap.get(t.normalized_form);
                if (level) totalInvertedLevel += 6 - level;
              });
              row.usefulnessData = { score: totalInvertedLevel };
            }
          }

          state.filteredIndices.sort((a, b) => {
            return (
              state.allData[b].usefulnessData.score -
              state.allData[a].usefulnessData.score
            );
          });

          state.isSortedByScore = true;
          statusEl.innerText = "Sorting complete";
          ui.sortBtn.innerHTML = `<span>âš¡</span> Sorted by Score`;
          ui.sortBtn.disabled = false;
          ui.loadingMsg.style.display = "none";
          state.currentPage = 1;
          renderTable();
        },

        changePage: (d) => {
          const t = Math.ceil(state.filteredIndices.length / 3) || 1;
          const n = state.currentPage + d;
          if (n > 0 && n <= t) {
            state.currentPage = n;
            renderTable();
          }
        },

        exportCSV: () => {
          const dataToExport = state.filteredIndices.map((i) => {
            const r = state.allData[i];
            return { jpid: r.jpid, jp: r.jp, enid: r.enid, en: r.en };
          });
          const csv = Papa.unparse(dataToExport, { delimiter: "\t" });
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `filtered.csv`;
          link.click();
        },
      };

      // --- Interaction Logic (Tooltip) ---
      window.handleMouseOver = async (e) => {
        // Use closest() to handle hovering over the ruby/rt tags inside the span
        const target = e.target.closest("[data-kanji]");
        if (!target) return;

        const kanji = target.getAttribute("data-kanji");

        tooltip.style.display = "block";
        tooltip.style.left = e.clientX + 15 + "px";
        tooltip.style.top = e.clientY + 15 + "px";
        tooltip.innerHTML = `<strong>${kanji}</strong><br/>Loading...`;

        const results = await searchDictionary(kanji);
        console.log(results);
        if (results) {
          let out = ``;
          results.forEach((g) => {
            out += `<div class="entry">`;
            if (g.info && g.info.length) out += `<i>${g.info}</i><br/>`;
            out += `${g.gloss.join(", ")}
              </div>`;
          });
          tooltip.innerHTML = out;
        } else {
          tooltip.innerHTML = `No definition found for "${kanji}"`;
        }
      };

      window.handleMouseOut = (e) => {
        // Hide if we leave the span (bubbling handles child elements)
        const target = e.target.closest("[data-kanji]");
        if (target) {
          tooltip.style.display = "none";
        }
      };

      ui.fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        ui.loadingMsg.style.display = "inline";
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          delimiter: "",
          complete: function (results) {
            processData(results.data);
            ui.loadingMsg.style.display = "none";
            ui.exportBtn.disabled = false;
            ui.sortBtn.disabled = false;
          },
          error: () => {
            alert("Error parsing CSV");
            ui.loadingMsg.style.display = "none";
          },
        });
      });

      function processData(rawData) {
        state.allData = [];
        rawData.forEach((row) => {
          const jpSentence = row.jp || "";
          if (jpSentence.length < MIN_LEN) return;
          const matches = jpSentence.match(kanjiRegex) || [];
          state.allData.push({
            jpid: row.jpid,
            jp: jpSentence,
            enid: row.enid,
            en: row.en,
            rowKanji: new Set(matches),
            usefulnessData: null, // Will be populated on sort
          });
        });
        window.app.applyFilters();
      }

      function renderTable() {
        const PAGE_SIZE = 10;

        const totalItems = state.filteredIndices.length;
        const totalPages = Math.ceil(totalItems / PAGE_SIZE) || 1;

        ui.countDisplay.textContent = `Rows: ${totalItems.toLocaleString()}`;
        ui.pageDisplay.textContent = `Page ${state.currentPage} / ${totalPages}`;
        ui.prevBtn.disabled = state.currentPage === 1;
        ui.nextBtn.disabled =
          state.currentPage === totalPages || totalItems === 0;

        const startIndex = (state.currentPage - 1) * PAGE_SIZE;
        const indices = state.filteredIndices.slice(
          startIndex,
          startIndex + PAGE_SIZE,
        );

        if (totalItems === 0) {
          ui.tableBody.innerHTML = `<tr><td colspan="2" style="text-align:center; padding:30px;">No rows match filters.</td></tr>`;
          return;
        }

        let html = "";
        for (let idx of indices) {
          const row = state.allData[idx];
          let jpDisplay = row.jp;

          // 1. Try to parse with Sudachi
          const tokens = sudachiParse(row.jp);

          if (tokens && tokens.length > 0) {
            jpDisplay = tokens
              .map((t) => {
                const surface = t.surface;
                const reading = t.reading_form
                  ? katakanaToHiragana(t.reading_form)
                  : surface;
                const dict = t.dictionary_form;

                // Generate Ruby (Furigana) if needed
                let content = surface;
                if (kanjiRegex.test(surface) && reading !== surface) {
                  content = generateRuby(surface, reading);
                }

                // Wrap in Highlight Span if in Usefulness Map
                // This happens immediately regardless of Sort button status
                if (state.usefulnessMap.has(dict)) {
                  return `<span class="highlighted-word" data-kanji="${dict}">${content}</span>`;
                }
                return content;
              })
              .join("");
          }

          html += `
        <tr>
          <td class="jp-col" onmouseover="handleMouseOver(event)" onmouseout="handleMouseOut(event)">${jpDisplay}</td>
          <td class="en-col">${row.en || ""}</td>
        </tr>
      `;
        }
        ui.tableBody.innerHTML = html;
      }
    </script>
  </body>
</html>
