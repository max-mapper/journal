<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Japanese Grammar & Dict Matcher</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f9;
        color: #333;
      }
      h1 {
        color: #2c3e50;
        padding: 20px;
        margin: 0;
        text-align: center;
        font-size: 1.5rem;
      }

      /* Controls Area */
      .controls-area {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
        margin-bottom: 10px;
      }
      .button-group {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      button {
        padding: 8px 16px;
        border: 1px solid #ccc;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        color: #444;
        transition: background 0.2s;
      }
      button:hover {
        background: #e9e9e9;
      }
      button.clear-btn {
        color: #c0392b;
        border-color: #e74c3c;
      }
      button.clear-btn:hover {
        background: #fce4e4;
      }

      /* Filter Toggles */
      .filters-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .options-row {
        display: flex;
        gap: 15px;
        padding: 10px;
        background: #e8f4fc;
        border-radius: 8px;
        border: 1px solid #d1e3f2;
      }
      .filters {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        background: white;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .filter-item {
        display: flex;
        align-items: center;
        font-size: 13px;
        cursor: pointer;
        user-select: none;
      }
      .filter-item input {
        margin-right: 6px;
        cursor: pointer;
      }
      .filter-item.bold-opt {
        font-weight: bold;
        color: #2980b9;
      }

      /* Main Layout */
      .container {
        display: flex;
        gap: 20px;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        height: 70vh;
      }
      .panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        min-height: 0;
      }
      .panel-header {
        padding: 15px;
        background: #eee;
        border-bottom: 1px solid #ddd;
        font-weight: bold;
      }
      textarea {
        flex: 1;
        border: none;
        padding: 15px;
        font-size: 18px;
        line-height: 1.6;
        resize: none;
        outline: none;
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
      }
      #output-display {
        flex: 1;
        padding: 15px;
        font-size: 22px;
        line-height: 2;
        overflow-y: auto;
        white-space: pre-wrap;
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
      }

      /* Responsive Mobile Layout */
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
          height: auto;
        }
        .panel {
          height: 400px;
        }
        h1 {
          font-size: 1.2rem;
          padding: 10px;
        }
        .options-row {
          flex-wrap: wrap;
        }
      }

      /* Furigana Styling */
      ruby rt {
        font-size: 0.5em;
        color: #666;
        user-select: none;
      }

      /* Toggle Furigana Class */
      body.hide-furigana ruby rt {
        display: none;
      }

      /* Highlight Styles */
      .grammar-match {
        background-color: #e3f2fd;
        border-bottom: 2px solid #2196f3;
        cursor: pointer;
        border-radius: 3px;
      }
      .dict-match {
        background-color: #f1f8e9;
        border-bottom: 2px solid #8bc34a;
        cursor: pointer;
        border-radius: 3px;
      }
      .grammar-match:hover {
        background-color: #bbdefb;
      }
      .dict-match:hover {
        background-color: #dcedc8;
      }
      .active {
        background-color: #ffe0b2 !important;
        border-bottom-color: #ff9800 !important;
      }

      /* Tooltip Styles */
      #grammar-tooltip {
        position: fixed;
        z-index: 1000;
        background: white;
        color: #333;
        padding: 0;
        border-radius: 6px;
        font-size: 14px;
        width: 320px;
        max-width: 90vw;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
        display: none;
        border: 1px solid #ccc;
        line-height: 1.4;
        max-height: 50vh;
        overflow-y: auto;
      }
      .tooltip-content {
        padding: 15px;
      }
      #grammar-tooltip h3 {
        margin: 0 0 5px 0;
        font-size: 18px;
        color: #2196f3;
      }
      .pos-badge {
        display: inline-block;
        background: #eee;
        color: #555;
        font-size: 0.75rem;
        padding: 2px 6px;
        border-radius: 4px;
        margin-bottom: 8px;
        font-weight: bold;
      }
      #grammar-tooltip .entry {
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #eee;
      }
      #grammar-tooltip .entry:last-child {
        border-bottom: none;
      }
      .dict-entry-group {
        margin-bottom: 12px;
        padding: 8px;
        background: #f9f9f9;
        border-radius: 4px;
      }
      .dict-entry-group h4 {
        margin: 0 0 5px 0;
        font-size: 12px;
        color: #666;
        text-transform: uppercase;
      }
      #grammar-tooltip a.ext-link {
        display: inline-block;
        background-color: #2c3e50;
        color: white;
        padding: 6px 12px;
        text-decoration: none;
        border-radius: 4px;
        font-size: 12px;
        margin-top: 5px;
        width: 100%;
        text-align: center;
        box-sizing: border-box;
      }

      .status-bar {
        padding: 10px;
        background: #2c3e50;
        color: white;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h1>Grammar Analyzer</h1>

    <div class="controls-area">
      <div class="button-group">
        <button id="btn-paste">ğŸ“‹ Paste from Clipboard</button>
        <button id="btn-clear" class="clear-btn">âŒ Clear</button>
      </div>

      <div class="filters-container">
        <!-- Main Options -->
        <div class="options-row">
          <label class="filter-item bold-opt"
            ><input type="checkbox" id="toggle-grammar" checked /> Highlight
            Grammar</label
          >
          <label class="filter-item bold-opt"
            ><input type="checkbox" id="toggle-furigana" checked /> Show
            Furigana</label
          >
        </div>

        <!-- POS Filters -->
        <div class="filters">
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="å‹•è©" />
            Verb (å‹•è©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="åŠ©å‹•è©" />
            Aux. Verb (åŠ©å‹•è©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="åŠ©è©" />
            Particle (åŠ©è©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="åè©" />
            Noun (åè©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="å½¢å®¹è©" />
            Adjective (å½¢å®¹è©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="å‰¯è©" />
            Adverb (å‰¯è©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="å½¢çŠ¶è©" />
            Na-Adj (å½¢çŠ¶è©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="ä»£åè©" />
            Pronoun (ä»£åè©)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="æ¥å°¾è¾" />
            Suffix (æ¥å°¾è¾)</label
          >
        </div>
      </div>
    </div>

    <div class="container">
      <div class="panel">
        <div class="panel-header">Input Japanese</div>
        <textarea id="input-text">
ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’å‹é”ã«ã‚ã’ã¾ã™ã€‚
æ˜æ—¥ã¯é›¨ãŒãµã‚‹ã¨æ€ã„ã¾ã™ã€‚
ãƒ‘ãƒ³ã‚’é£Ÿã¹ã¾ã—ãŸã€‚ãŠè…¹ãŒç©ºã„ãŸã‹ã‚‰ã§ã™ã€‚
ã‚¢ãƒ¡ãƒªã‚«ã‹ã‚‰æ¥ã¾ã—ãŸã€‚
ä½•äººãã‚‰ã„æ¥ã¾ã™ã‹ã€‚
å‹é”ãŒç§ã«ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’ãã‚Œã¾ã—ãŸã€‚
æ—¥æœ¬èªã®æ£®ã§åƒããŸã„ã§ã™ã€‚
ã“ã“ã®ãƒ‘ã‚½ã‚³ãƒ³ã¯å­¦ç”Ÿã ã‘ãŒä½¿ãˆã¾ã™ã€‚
å¤§å­¦ã«è¡Œãã¤ã‚‚ã‚Šã§ã™ã€‚
ã“ã‚Œã‹ã‚‰åœ°çƒã®æ¸©åº¦ãŒã ã‚“ã ã‚“é«˜ããªã£ã¦ã„ãã€‚
ä»Šã€æœã”ã¯ã‚“ã‚’é£Ÿã¹ã¦ã„ã¾ã™ã€‚
å…ˆç”Ÿã«èã„ã¦ãã ã•ã„ã€‚
ä»–ã®äººã‚’å‚·ã¤ã‘ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚
ä»•äº‹ã¯å¿™ã—ã„ã§ã™ã€‚ã§ã‚‚ã€æ¥½ã—ã„ã§ã™ã€‚
å¸°ã£ã¦ã‚‚ã„ã„ã§ã™ã‹ã€‚
ã“ã“ã«æ¥ã¦ãã ã•ã„ã€‚
å®¿é¡Œã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ã€‚
ã‚¸ãƒ¥ãƒ›ã•ã‚“ã¯éŸ“å›½äººã˜ã‚ƒãªã„ã§ã™ã‹ã€‚
å¤§äººã«ãªã‚Šã¾ã—ãŸã€‚
ã‚²ãƒ¼ãƒ ã‚’ã—ã¾ã—ã‚‡ã†ã€‚
ã‚«ãƒ•ã‚§ã«è¡Œãã¾ã—ã‚‡ã†ã‹ã€‚
ãƒ†ãƒ¬ãƒ“ã‚’è¦‹ã¾ã›ã‚“ã‹ã€‚
æˆæ¥­ã¯4æ™‚ã¾ã§ã§ã™ã€‚
ç§ã¯å‹é”ã«ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’ã‚‚ã‚‰ã„ã¾ã—ãŸã€‚
ãƒ†ã‚¹ãƒˆã®å‰ã«å‹‰å¼·ã—ã¾ã™ã€‚
æˆæ¥­ã®å¾Œã§å¸°ã‚Šã¾ã—ãŸã€‚
ã“ã®æ¼¢å­—ã®èª­ã¿æ–¹ã¯ä½•ã§ã™ã‹ã€‚
ãŸãã•ã‚“æœ¬ãŒã‚ã‚Šã¾ã™ã€‚
æœ9æ™‚ã«èµ·ãã¾ã—ãŸã€‚
æ˜ ç”»ã‚’è¦‹ã‚‹ã“ã¨ãŒå¥½ãã§ã™ã€‚
è¨€ã„é–“é•ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
å½¼ã¯å‹é”ã‚’ã†ã‚‰ãã‚‹ã“ã¨ã¯ãªã„ã€‚
çŒ«ã¨çŠ¬ãŒå¥½ãã ã€‚
ãŠèŒ¶ã¨æ°´ã¨ã€ã©ã¡ã‚‰ãŒã„ã„ã§ã™ã‹ã€‚
ãƒ•ã‚¡ãƒŸãƒªãƒ¼ãƒãƒ¼ãƒˆã¨ã„ã†ã‚³ãƒ³ãƒ“ãƒ‹ã‚’çŸ¥ã£ã¦ã„ã¾ã™ã‹ã€‚
ã‚¿ãƒ©ã¨è¨€ã„ã¾ã™ã€‚
7æ™‚ã«èµ·ãã¾ã™ã€‚
æ–°å®¿ã¯æ±äº¬ã«ã‚ã‚‹ã€‚
æ—¥æœ¬ã«åƒãã«æ¥ãŸã€‚
ã“ã‚Œã¯ãƒšãƒ³ã§ã™ã€‚
ã‚†ã‹ã•ã‚“ã¯å…ˆç”Ÿã§ã™ã€‚
ä»Šã‹ã‚‰ä¼‘æ†©ãŒå§‹ã¾ã‚Šã¾ã™ã€‚
æ˜¨æ—¥4æ™‚ã«å¸°ã‚Šã¾ã—ãŸã€‚
çŒ«ã¯ã‹ã‚ã„ã„ã€‚
ä»Šæ—¥å‹‰å¼·ã—ãŸã‚Šã€è²·ã„ç‰©ã‚’ã—ãŸã‚Šã—ã¾ã—ãŸã€‚
èª•ç”Ÿæ—¥ã¯ã„ã¤ã§ã™ã‹ã€‚
å›³æ›¸é¤¨ã§å‹‰å¼·ã—ã¾ã™ã€‚
ãƒœãƒ¼ãƒ«ã‚’è½ã¨ã—ãŸã€‚
æ–°å®¿ã¸è¡Œãã¾ã™ã€‚
èª°ãŒé–¢è¥¿å‡ºèº«ã§ã™ã‹ã€‚
å…„å¼Ÿã¨ã‚ˆãã‘ã‚“ã‹ã—ã¾ã™ã€‚
ã“ã‚Œã¯ç§ã®ãƒšãƒ³ã ã€‚
ç§ã‚‚å­¦ç”Ÿã§ã™ã€‚
ç‰›ä¹³ã‚„åµã‚’è²·ã„ã¾ã—ãŸã€‚
1æ™‚ã”ã‚ä¼šè­°ãŒã‚ã‚Šã¾ã™ã€‚
æ—¥æœ¬ã«å¥½ããªé£Ÿã¹ç‰©ãŒã‚ã¾ã‚Šãªã„ã€‚
é­šã¯ãœã‚“ãœã‚“å¥½ãã˜ã‚ƒãªã„ã€‚
æœ¬ã‚’3å†Šè²·ã„ã¾ã™ã€‚
ã“ã®ãƒšãƒ³ã¯é’ã„ã€‚
å®¶ã¯éƒµä¾¿å±€ã®å³ã«ã‚ã‚Šã¾ã™ã€‚
å½¼ã¯èƒŒãŒé«˜ã„ã§ã™ã€‚
æ­Œã†ã®ãŒå¥½ãã§ã™ã€‚
ä¸Šç”°ãã‚“ã¯å“çƒãŒä¸Šæ‰‹ã ã€‚
å»Šä¸‹ã‚’é™ã‹ã«æ­©ã„ãŸã€‚
æ—¥æœ¬ã¨ã‚¢ãƒ¡ãƒªã‚«ã¨ã€ã©ã¡ã‚‰ã®ã»ã†ãŒå¤§ãã„ï¼Ÿ
ã‚¢ãƒ¡ãƒªã‚«ã¯æ—¥æœ¬ã‚ˆã‚Šå¤§ãã„ã§ã™ã€‚
é£Ÿã¹ç‰©ã®ä¸­ã§ã€ãƒ‘ãƒ³ãŒä¸€ç•ªãŠã„ã—ã„ã§ã™ã€‚
æ˜æ—¥é›¨ãŒãµã‚‹ã§ã—ã‚‡ã†ã€‚
éƒ½ä¼šã¯ã†ã‚‹ã•ã™ãã‚‹ã€‚
ãŠé‡‘ãŒã»ã—ã„ã§ã™ã€‚
æ°´ã‚’ãã ã•ã„ã€‚
å®¶ã«å¸°ã£ã¦ã€ã‚·ãƒ£ãƒ¯ãƒ¼ã‚’æµ´ã³ã¾ã—ãŸã€‚
å­¦ç”Ÿã§ã€æ—¥æœ¬ã«ä½ã‚“ã§ã„ã‚‹ã€‚
ã¾ã å®¶ã‹ã‚‰å‡ºã¦ã„ãªã„ã§ã™ã€‚
å½¼ã¯ã‚‚ã†å¸°ã‚Šã¾ã—ãŸã€‚
å®¿é¡Œã‚’ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ã‚³ãƒ¼ãƒ’ãƒ¼ã˜ã‚ƒãªãã¦ãŠèŒ¶ã‚’ãã ã•ã„ã€‚
æ—¥æœ¬èªã‚’å‹‰å¼·ã™ã‚‹ã€‚
æ¯ãŒãã‚ŒãŸæ™‚è¨ˆã¯å¤ã„ã§ã™ã€‚
å†·è”µåº«ã«ä½•ã‚‚ãªã„ã§ã™ã€‚

é¶è‚‰ã¯ã‚ã¾ã‚Šå¥½ãã˜ã‚ƒãªã„ã€‚
ä»•äº‹ãŒçµ‚ã‚ã£ãŸã‚ã¨ã§ã€ã‚¸ãƒ ã«è¡Œãã€‚
ã‚ãªãŸãŒè¡Œã‘ã°ã€ç§ã‚‚è¡Œãã¾ã™ã€‚
é›¨ãŒé™ã‚‰ãªã„å ´åˆã¯æ³³ãã¾ã™ã€‚
äºŒäººã ã‘ã§å°‘ã—è©±ãŒã—ãŸã„ã€‚
é›¨ãŒé™ã‚Šã ã—ãŸã€‚
æš‡ã ã‹ã‚‰ã€ã‚²ãƒ¼ãƒ ã§ã‚‚ã—ã¾ã—ã‚‡ã†ã€‚
ã“ã®çŒ«ã¯èª°ã‚‚æ¬²ã—ãŒã‚‹äººãŒã„ãªã‹ã£ãŸã€‚
æ—¥æœ¬èªã‚’å‹‰å¼·ã—å§‹ã‚ã¦ã€ã‚‚ã†å››å¹´çµŒã£ãŸã€‚
ãã®èˆ¹ã¯æ²ˆã‚€ã¯ãšãŒãªã„ã€‚
é£Ÿã¹ç‰©ãŒå¿…è¦ã§ã™ã€‚
é£Ÿã¹ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ç¾å‘³ã—ã„æ™©ã”ã¯ã‚“ãŒæ¬²ã—ã„ã€‚
ã“ã®ã‚²ãƒ¼ãƒ ã¯é›£ã—ã„ã‚“ã˜ã‚ƒãªã„ã‹ã€‚
å½¼ãŒé©šãã‹ã©ã†ã‹ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚
æ¼«ç”»ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
å¯¿å¸ã®é£Ÿã¹æ–¹ã‚’æ•™ãˆã¦ãã‚Œã¾ã›ã‚“ã‹ã€‚
æœ‰åäººã˜ã‚ƒãªã„ã‹ã—ã‚‰ï¼Ÿ
å­ä¾›ã¿ãŸã„ã§ã™ã€‚
ãƒ†ãƒ¬ãƒ“ã‚’è¦‹ãªãŒã‚‰æ™©ã”ã¯ã‚“ã‚’é£Ÿã¹ã¾ã™ã€‚
å¯ãªã„ã§å‹‰å¼·ã‚’ã—ã¾ã™ã€‚
å‹‰å¼·ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
å­¦æ ¡ã«è¡Œã‹ãªãã¦ã‚‚ã„ã„ã€‚
æ—¥æœ¬èªã‚’ç¿’ã„ãŸã„ã®ãªã‚‰ã€ã“ã®æœ¬ãŒã„ã„ã§ã™ã‚ˆã€‚
ã¡ã‚‡ã£ã¨å¾…ã¡ãªã•ã„ã€‚
ãŠæ¯ã•ã‚“ãŒå¸°ã£ã¦ããŸã“ã¨ã«æ°—ãŒã¤ãã€‚
ã“ã®è³ªå•ã«ã¯ç­”ãˆã«ãã„ã§ã™ã€‚
è¨€èªã®ä¸­ã§æ—¥æœ¬èªãŒä¸€ç•ªé›£ã—ã„ã¨æ€ã„ã¾ã™ã€‚
ã”ã¯ã‚“ã‚’ä½œã‚‹ã®ã«ä¸€æ™‚é–“ã‹ã‹ã‚Šã¾ã™ã€‚
ã“ã®ä»•äº‹ã¯ç§ãŒã„ãŸã—ã¾ã™ã€‚
çš†ãŒå­ä¾›ã®ã‚ˆã†ã«å…ƒæ°—ã«æ­Œã„å§‹ã‚ãŸã€‚
ï¼•ãƒ¡ãƒ¼ãƒˆãƒ«ãŠãã«æœ¨ã‚’æ¤ãˆã¾ã—ãŸã€‚
ã‚¿ãƒã‚³ã‚’æ­¢ã‚ã‚‰ã‚Œãªã„ã€‚
å¦¹ãŒéƒ¨å±‹ã«ã„ãªã„ã‚‰ã—ã„ã€‚
ä»Šå¹´ã®æš‘ã•ã¯æ™®é€šã§ã¯ãªã„ã€‚
æ¯ã¯ç§ã«è‡ªåˆ†ã®éƒ¨å±‹ã‚’ç‰‡ä»˜ã‘ã•ã›ãŸã€‚
æ¯æ—¥æ¯ã«é‡èœã‚’é£Ÿã¹ã•ã›ã‚‰ã‚Œã‚‹ã€‚
ã•ã™ãŒã®å½¼ã‚‚å¦»ã«ã¯å‹ã¦ãªã‹ã£ãŸã€‚
ç®±ã®ä¸­ã«åµã¯ä¸€å€‹ã—ã‹æ®‹ã£ã¦ã„ãªã„ã€‚
æ—¥æœ¬ã«æ¥ãŸã°ã‹ã‚Šã§ã™ã€‚
å¦¹ã¯ãã®é¦¬ã«ä¹—ã‚ŠãŸãŒã£ã¦ã„ã‚‹ã€‚
å¯‚ã—ã‹ã£ãŸã‚‰é›»è©±ã‚’ãã ã•ã„ã€‚
å®¿é¡Œã‚’ã—ãŸã‚‰ã©ã†ã§ã™ã‹ã€‚
ã‚ãªãŸã®ã“ã¨ã‚’è©±ã—ã¦ãŸã¨ã“ã‚ã ã‚ˆã€‚
æ˜æ—¥äº‹å‹™æ‰€ã«è¡Œã£ã¦ã»ã—ã„ã€‚
ç§ã¯ä»Šã€å®¶ã§æ—¥æœ¬èªã‚’å‹‰å¼·ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã™ã€‚
ã“ã®ã‚µãƒ©ãƒ€ãŒã™ã”ãç¾å‘³ã—ã„ã‚ˆã€‚é£Ÿã¹ã¦ã¿ã¦ã€‚
é›¨ã§ã‚‚è¡Œãã¾ã—ã‚‡ã†ã€‚
ã“ã®æ–‡ç« ã¯é‡è¦ã§ã™ã€‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚
å›ã«ä¼šãˆã¦ã‚ˆã‹ã£ãŸã€‚
æ—¥æœ¬èªã¯æœ€ã‚‚é›£ã—ã„è¨€èªã ã¨è¨€ã‚ã‚Œã¦ã„ã‚‹ã€‚
ãã®è¾ºã‚Šã¯ã¨ã¦ã‚‚è³‘ã‚„ã‹ã ã¨èã„ãŸã€‚
ã“ã‚Œã‹ã‚‰ãƒ‘ãƒ³ã‚’ç„¼ãã¨ã“ã‚ã§ã™ã€‚
ä»•äº‹ã‚’ç¶šã‘ã‚‹ã®ã¯ç„¡ç†ã ã¨æ€ã†ã€‚
ä¸€æ—¥ä¸­é›¨ãŒé™ã‚Šç¶šãã€‚
å»ºç‰©ã®ä¸­ã¯ã„ã¤ã‚‚ã‚ˆã‚Šæš—ã‹ã£ãŸã€‚
ç§ã¯ç•™å­¦ã‚’ã™ã‚‹äºˆå®šã§ã™ã€‚
ï¼•å¹´é–“æ—¥æœ¬èªã‚’å‹‰å¼·ã—ã¦ã€æ—¥æœ¬èªãŒè©±ã›ã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚
ãã®ã“ã¨ã¯å…¨ç„¶çŸ¥ã‚Šã¾ã›ã‚“ã€‚</textarea
        >
      </div>
      <div class="panel">
        <div class="panel-header">Analysis (Click words for details)</div>
        <div id="output-display"></div>
        <div class="status-bar" id="status-bar">Initializing...</div>
      </div>
    </div>
    <div id="grammar-tooltip"><div class="tooltip-content"></div></div>

    <script type="module">
      import { GrammarRule } from "./grammar-engine.js";
      import GRAMMAR_RULES from "./grammar-rules.js";
      import { SudachiStateless } from "./sudachi-wasm/sudachi.js";

      const inputText = document.getElementById("input-text");
      const outputDisplay = document.getElementById("output-display");
      const statusBar = document.getElementById("status-bar");
      const tooltip = document.getElementById("grammar-tooltip");
      const tooltipContent = tooltip.querySelector(".tooltip-content");

      const filterInputs = document.querySelectorAll(".pos-filter");
      const toggleGrammar = document.getElementById("toggle-grammar");
      const toggleFurigana = document.getElementById("toggle-furigana");

      // Buttons
      const btnPaste = document.getElementById("btn-paste");
      const btnClear = document.getElementById("btn-clear");

      let state = { sudachi: null, dictDB: null };
      window.state = state;

      // --- Helper Utilities ---
      async function fetchAndGunzip(url) {
        const response = await fetch(url);
        const ds = new DecompressionStream("gzip");
        const stream = response.body.pipeThrough(ds);
        return await new Response(stream).blob();
      }

      function katakanaToHiragana(src) {
        return src.replace(/[\u30a1-\u30f6]/g, (m) =>
          String.fromCharCode(m.charCodeAt(0) - 0x60),
        );
      }

      function generateRuby(surface, reading) {
        if (!reading || surface === reading || !/[\u4e00-\u9faf]/.test(surface))
          return surface;

        let sEnd = surface.length,
          rEnd = reading.length;
        while (
          sEnd > 0 &&
          rEnd > 0 &&
          surface[sEnd - 1] === reading[rEnd - 1]
        ) {
          sEnd--;
          rEnd--;
        }

        let sStart = 0,
          rStart = 0;
        while (
          sStart < sEnd &&
          rStart < rEnd &&
          surface[sStart] === reading[rStart]
        ) {
          sStart++;
          rStart++;
        }

        const prefix = surface.substring(0, sStart);
        const suffix = surface.substring(sEnd);
        const coreS = surface.substring(sStart, sEnd);
        const coreR = reading.substring(rStart, rEnd);

        return coreS
          ? `${prefix}<ruby>${coreS}<rt>${coreR}</rt></ruby>${suffix}`
          : surface;
      }

      async function searchDictionary(term) {
        if (!state.dictDB) return null;
        let indices = state.dictDB.index[term];

        if (!indices && term.length > 1) {
          indices = state.dictDB.index[term.slice(0, -1)];
        }

        if (!indices) return null;
        return indices.map((idx) => state.dictDB.defs[idx]);
      }

      // --- Initialization ---
      async function initResources() {
        try {
          statusBar.innerText = "Loading Sudachi...";
          const dictBlob = await fetchAndGunzip(
            "sudachi-wasm/resources/system.dic.gz",
          );
          state.sudachi = new SudachiStateless();
          await state.sudachi.initialize_from_bytes(
            new Uint8Array(await dictBlob.arrayBuffer()),
          );

          statusBar.innerText = "Loading Dictionary...";
          const jpDictBlob = await fetchAndGunzip("jpdict.json.gz");
          state.dictDB = JSON.parse(await jpDictBlob.text());

          statusBar.innerText = "Ready";
          runAnalysis();
        } catch (err) {
          statusBar.innerText = "Error: " + err.message;
          console.error(err);
        }
      }

      // --- Core Logic ---
      async function runAnalysis() {
        if (!state.sudachi || !state.dictDB) return;
        const text = inputText.value;
        if (!text.trim()) {
          outputDisplay.innerHTML = "";
          return;
        }

        // Get Options
        const activePOS = new Set();
        filterInputs.forEach((input) => {
          if (input.checked) activePOS.add(input.value);
        });
        const isGrammarEnabled = toggleGrammar.checked;

        // 1. Tokenize
        const tokens = JSON.parse(state.sudachi.tokenize_stringified(text, 0));

        // 2. Scan for Grammar (only if enabled)
        let activeGrammar = [];
        if (isGrammarEnabled) {
          let grammarRanges = [];
          for (const ruleJson of GRAMMAR_RULES) {
            const rule = new GrammarRule(ruleJson);
            const matches = rule.scan(tokens);
            matches.forEach((m) => {
              grammarRanges.push({
                start: m.index,
                end: m.index + m.length,
                data: ruleJson,
                type: "grammar",
              });
            });
          }
          // Resolve grammar overlaps (longest match first)
          grammarRanges.sort(
            (a, b) => b.end - b.start - (a.end - a.start) || a.start - b.start,
          );
          const usedTokens = new Set();
          for (const r of grammarRanges) {
            let conflict = false;
            for (let i = r.start; i < r.end; i++)
              if (usedTokens.has(i)) conflict = true;
            if (!conflict) {
              activeGrammar.push(r);
              for (let i = r.start; i < r.end; i++) usedTokens.add(i);
            }
          }
        }

        // 3. Render
        let html = "";
        for (let i = 0; i < tokens.length; i++) {
          const gMatch = activeGrammar.find((r) => r.start === i);

          if (gMatch) {
            // Render Grammar Block
            let blockContent = "";
            for (let j = gMatch.start; j < gMatch.end; j++) {
              blockContent += generateRuby(
                tokens[j].surface,
                katakanaToHiragana(tokens[j].reading_form),
              );
            }
            html += `<span class="grammar-match" 
                           data-type="grammar"
                           data-title="${gMatch.data.title}" 
                           data-desc="${gMatch.data.description}" 
                           data-link="${gMatch.data.link || "#"}">${blockContent}</span>`;
            i = gMatch.end - 1;
          } else {
            // Single Token Handling
            const token = tokens[i];

            // Handle POS property difference (pos vs poses)
            const posList = token.poses || token.pos;
            const pos = posList ? posList[0] : "Unk";

            const content = generateRuby(
              token.surface,
              katakanaToHiragana(token.reading_form),
            );

            // Dictionary highlight check
            if (activePOS.has(pos)) {
              // Quick check if dict entry exists (optimization)
              const hasDef =
                !!state.dictDB.index[token.dictionary_form] ||
                (token.dictionary_form.length > 1 &&
                  !!state.dictDB.index[token.dictionary_form.slice(0, -1)]);

              if (hasDef) {
                html += `<span class="dict-match" 
                               data-type="dict"
                               data-kanji="${token.dictionary_form}"
                               data-surface="${token.surface}"
                               data-pos="${pos}">${content}</span>`;
              } else {
                html += content;
              }
            } else {
              html += content;
            }
          }
        }
        outputDisplay.innerHTML = html;
      }

      // --- Tooltip Interaction ---
      async function showTooltip(el) {
        const type = el.dataset.type;
        tooltip.style.display = "block";
        tooltipContent.innerHTML = "Loading...";

        if (type === "grammar") {
          tooltipContent.innerHTML = `
            <h3>${el.dataset.title}</h3>
            <p>${el.dataset.desc}</p>
            ${el.dataset.link !== "#" ? `<a class="ext-link" href="${el.dataset.link}" target="_blank">Check Bunpro &rarr;</a>` : ""}
          `;
        } else {
          // Dictionary Logic
          const kanji = el.dataset.kanji;
          const pos = el.dataset.pos;
          const entryGroups = await searchDictionary(kanji);

          if (entryGroups && entryGroups.length > 0) {
            let out = `<h3>${kanji}</h3>`;
            if (pos) {
              out += `<div class="pos-badge">${pos}</div>`;
            }

            entryGroups.forEach((senses, index) => {
              out += `<div class="dict-entry-group">`;
              if (entryGroups.length > 1) {
                out += `<h4>Entry ${index + 1}</h4>`;
              }

              senses.forEach((sense) => {
                out += `<div class="entry">
                  ${sense.info && sense.info.length ? `<span style="color:#e67e22; font-size:0.9em;">[${sense.info.join(", ")}]</span><br/>` : ""}
                  ${sense.gloss.join(", ")}
                </div>`;
              });
              out += `</div>`;
            });

            out += `<a class="ext-link" href="${`https://jotoba.de/search/0/${encodeURIComponent(kanji)}`}" target="_blank">View on Jotoba</a>`;
            tooltipContent.innerHTML = out;
          } else {
            tooltipContent.innerHTML = "No definition found.";
          }
        }

        // Positioning Logic
        const rect = el.getBoundingClientRect();
        const tooltipWidth = 320;
        let left = rect.left + window.scrollX;

        if (left + tooltipWidth > window.innerWidth) {
          left = window.innerWidth - tooltipWidth - 10;
        }
        if (left < 0) left = 10;

        let top = rect.bottom + window.scrollY + 10;
        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;

        el.classList.add("active");
      }

      // --- Event Listeners ---

      document.addEventListener("click", (e) => {
        const match = e.target.closest(".grammar-match, .dict-match");
        document
          .querySelectorAll(".active")
          .forEach((el) => el.classList.remove("active"));

        if (match) {
          e.stopPropagation();
          showTooltip(match);
        } else if (!e.target.closest("#grammar-tooltip")) {
          tooltip.style.display = "none";
        }
      });

      document.addEventListener(
        "scroll",
        () => {
          // keep tooltip open but maybe close if necessary
        },
        true,
      );

      // Paste / Clear
      btnPaste.addEventListener("click", async () => {
        try {
          const text = await navigator.clipboard.readText();
          inputText.value = text;
          runAnalysis();
        } catch (err) {
          alert("Failed to read clipboard contents: " + err);
        }
      });

      btnClear.addEventListener("click", () => {
        inputText.value = "";
        runAnalysis();
      });

      // Filter & Toggles
      const allToggles = [...filterInputs, toggleGrammar];
      allToggles.forEach((input) => {
        input.addEventListener("change", runAnalysis);
      });

      // Furigana Toggle (CSS Class)
      toggleFurigana.addEventListener("change", (e) => {
        if (e.target.checked) {
          document.body.classList.remove("hide-furigana");
        } else {
          document.body.classList.add("hide-furigana");
        }
      });

      // Live Typing
      let timeout;
      inputText.addEventListener("input", () => {
        clearTimeout(timeout);
        timeout = setTimeout(runAnalysis, 400);
      });

      initResources();
    </script>
  </body>
</html>
