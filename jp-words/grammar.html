<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Japanese Grammar & Dict Matcher</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f9;
        color: #333;
      }
      h1 {
        color: #2c3e50;
        padding: 20px;
        margin: 0;
        text-align: center;
      }
      .container {
        display: flex;
        gap: 20px;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        height: 80vh;
      }
      .panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        min-height: 0;
      }
      .panel-header {
        padding: 15px;
        background: #eee;
        border-bottom: 1px solid #ddd;
        font-weight: bold;
      }
      textarea {
        flex: 1;
        border: none;
        padding: 15px;
        font-size: 18px;
        line-height: 1.6;
        resize: none;
        outline: none;
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
      }
      #output-display {
        flex: 1;
        padding: 15px;
        font-size: 22px;
        line-height: 2;
        overflow-y: auto;
        white-space: pre-wrap;
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
      }

      /* Furigana Styling */
      ruby rt {
        font-size: 0.5em;
        color: #666;
      }

      /* Highlight Styles */
      .grammar-match {
        background-color: #e3f2fd;
        border-bottom: 2px solid #2196f3;
        cursor: pointer;
        border-radius: 3px;
      }
      .dict-match {
        background-color: #f1f8e9;
        border-bottom: 2px solid #8bc34a;
        cursor: pointer;
        border-radius: 3px;
      }
      .grammar-match:hover {
        background-color: #bbdefb;
      }
      .dict-match:hover {
        background-color: #dcedc8;
      }
      .active {
        background-color: #ffe0b2 !important;
        border-bottom-color: #ff9800 !important;
      }

      /* Tooltip Styles */
      #grammar-tooltip {
        position: absolute;
        z-index: 1000;
        background: white;
        color: #333;
        padding: 15px;
        border-radius: 6px;
        font-size: 14px;
        max-width: 320px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        display: none;
        border: 1px solid #ddd;
        line-height: 1.4;
      }
      #grammar-tooltip h3 {
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #2196f3;
      }
      #grammar-tooltip .entry {
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #eee;
      }
      #grammar-tooltip a {
        display: inline-block;
        background-color: #2c3e50;
        color: white;
        padding: 6px 12px;
        text-decoration: none;
        border-radius: 4px;
        font-size: 12px;
        margin-top: 5px;
      }

      .status-bar {
        padding: 10px;
        background: #2c3e50;
        color: white;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h1>Grammar Analyzer</h1>
    <div class="container">
      <div class="panel">
        <div class="panel-header">Input Japanese</div>
        <textarea id="input-text">
ジュースを友達にあげます。
明日は雨がふると思います。
パンを食べました。お腹が空いたからです。
アメリカから来ました。
何人ぐらい来ますか。
友達が私にジュースをくれました。
日本語の森で働きたいです。
ここのパソコンは学生だけが使えます。
大学に行くつもりです。
これから地球の温度がだんだん高くなっていく。
今、朝ごはんを食べています。
先生に聞いてください。
他の人を傷つけてはいけません。
仕事は忙しいです。でも、楽しいです。
帰ってもいいですか。
ここに来てください。
宿題を忘れないでください。
ジュホさんは韓国人じゃないですか。
大人になりました。
ゲームをしましょう。
カフェに行きましょうか。
テレビを見ませんか。
授業は4時までです。
私は友達にジュースをもらいました。
テストの前に勉強します。
授業の後で帰りました。
この漢字の読み方は何ですか。
たくさん本があります。
朝9時に起きました。
映画を見ることが好きです。
言い間違うことがあります。
彼は友達をうらぎることはない。
猫と犬が好きだ。
お茶と水と、どちらがいいですか。
ファミリーマートというコンビニを知っていますか。
タラと言います。
7時に起きます。
新宿は東京にある。
日本に働きに来た。
これはペンです。
ゆかさんは先生です。
今から休憩が始まります。
昨日4時に帰りました。
猫はかわいい。
今日勉強したり、買い物をしたりしました。
誕生日はいつですか。
図書館で勉強します。
ボールを落とした。
新宿へ行きます。
誰が関西出身ですか。
兄弟とよくけんかします。
これは私のペンだ。
私も学生です。
牛乳や卵を買いました。
1時ごろ会議があります。
日本に好きな食べ物があまりない。
魚はぜんぜん好きじゃない。
本を3冊買います。
このペンは青い。
家は郵便局の右にあります。
彼は背が高いです。
歌うのが好きです。
上田くんは卓球が上手だ。
廊下を静かに歩いた。
日本とアメリカと、どちらのほうが大きい？
アメリカは日本より大きいです。
食べ物の中で、パンが一番おいしいです。
明日雨がふるでしょう。
都会はうるさすぎる。
お金がほしいです。
水をください。
家に帰って、シャワーを浴びました。
学生で、日本に住んでいる。
まだ家から出ていないです。
彼はもう帰りました。
宿題をしなければなりません。
コーヒーじゃなくてお茶をください。
日本語を勉強する。
母がくれた時計は古いです。
冷蔵庫に何もないです。

鶏肉はあまり好きじゃない。
仕事が終わったあとで、ジムに行く。
あなたが行けば、私も行きます。
雨が降らない場合は泳ぎます。
二人だけで少し話がしたい。
雨が降りだした。
暇だから、ゲームでもしましょう。
この猫は誰も欲しがる人がいなかった。
日本語を勉強し始めて、もう四年経った。
その船は沈むはずがない。
食べ物が必要です。
食べる必要がある。
美味しい晩ごはんが欲しい。
このゲームは難しいんじゃないか。
彼が驚くかどうかわかりません。
漫画があるかもしれません。
寿司の食べ方を教えてくれませんか。
有名人じゃないかしら？
子供みたいです。
テレビを見ながら晩ごはんを食べます。
寝ないで勉強をします。
勉強しなければならない。
学校に行かなくてもいい。
日本語を習いたいのなら、この本がいいですよ。
ちょっと待ちなさい。
お母さんが帰ってきたことに気がつく。
この質問には答えにくいです。
言語の中で日本語が一番難しいと思います。
ごはんを作るのに一時間かかります。
この仕事は私がいたします。
皆が子供のように元気に歌い始めた。
５メートルおきに木を植えました。
タバコを止められない。
妹が部屋にいないらしい。
今年の暑さは普通ではない。
母は私に自分の部屋を片付けさせた。
毎日母に野菜を食べさせられる。
さすがの彼も妻には勝てなかった。
箱の中に卵は一個しか残っていない。
日本に来たばかりです。
妹はその馬に乗りたがっている。
寂しかったら電話をください。
宿題をしたらどうですか。
あなたのことを話してたところだよ。
明日事務所に行ってほしい。
私は今、家で日本語を勉強しているところです。
このサラダがすごく美味しいよ。食べてみて。
雨でも行きましょう。
この文章は重要です。覚えておいてください。
君に会えてよかった。
日本語は最も難しい言語だと言われている。
その辺りはとても賑やかだと聞いた。
これからパンを焼くところです。
仕事を続けるのは無理だと思う。
一日中雨が降り続く。
建物の中はいつもより暗かった。
私は留学をする予定です。
５年間日本語を勉強して、日本語が話せるようになった。
そのことは全然知りません。</textarea
        >
      </div>
      <div class="panel">
        <div class="panel-header">Analysis (Click words for details)</div>
        <div id="output-display"></div>
        <div class="status-bar" id="status-bar">Initializing...</div>
      </div>
    </div>
    <div id="grammar-tooltip"></div>

    <script type="module">
      import { GrammarRule } from "./grammar-engine.js";
      import GRAMMAR_RULES from "./grammar-rules.js";
      import { SudachiStateless } from "./sudachi-wasm/sudachi.js";

      const inputText = document.getElementById("input-text");
      const outputDisplay = document.getElementById("output-display");
      const statusBar = document.getElementById("status-bar");
      const tooltip = document.getElementById("grammar-tooltip");

      let state = { sudachi: null, dictDB: null };

      // --- Helper Utilities ---
      async function fetchAndGunzip(url) {
        const response = await fetch(url);
        const ds = new DecompressionStream("gzip");
        const stream = response.body.pipeThrough(ds);
        return await new Response(stream).blob();
      }

      function katakanaToHiragana(src) {
        return src.replace(/[\u30a1-\u30f6]/g, (m) =>
          String.fromCharCode(m.charCodeAt(0) - 0x60),
        );
      }

      function generateRuby(surface, reading) {
        if (!reading || surface === reading || !/[\u4e00-\u9faf]/.test(surface))
          return surface;

        let sEnd = surface.length,
          rEnd = reading.length;
        while (
          sEnd > 0 &&
          rEnd > 0 &&
          surface[sEnd - 1] === reading[rEnd - 1]
        ) {
          sEnd--;
          rEnd--;
        }

        let sStart = 0,
          rStart = 0;
        while (
          sStart < sEnd &&
          rStart < rEnd &&
          surface[sStart] === reading[rStart]
        ) {
          sStart++;
          rStart++;
        }

        const prefix = surface.substring(0, sStart);
        const suffix = surface.substring(sEnd);
        const coreS = surface.substring(sStart, sEnd);
        const coreR = reading.substring(rStart, rEnd);

        return coreS
          ? `${prefix}<ruby>${coreS}<rt>${coreR}</rt></ruby>${suffix}`
          : surface;
      }

      async function searchDictionary(term) {
        if (!state.dictDB) return null;
        let idx = state.dictDB.index[term];
        if (!idx && term.length > 1) {
          // Basic stem logic for dictionary lookups
          idx = state.dictDB.index[term.slice(0, -1)];
        }
        return idx ? state.dictDB.defs[idx[0]] : null;
      }

      // --- Initialization ---
      async function initResources() {
        try {
          statusBar.innerText = "Loading Sudachi...";
          const dictBlob = await fetchAndGunzip(
            "sudachi-wasm/resources/system.dic.gz",
          );
          state.sudachi = new SudachiStateless();
          await state.sudachi.initialize_from_bytes(
            new Uint8Array(await dictBlob.arrayBuffer()),
          );

          statusBar.innerText = "Loading Dictionary...";
          const jpDictBlob = await fetchAndGunzip("jpdict.json.gz");
          state.dictDB = JSON.parse(await jpDictBlob.text());

          statusBar.innerText = "Ready";
          runAnalysis();
        } catch (err) {
          statusBar.innerText = "Error: " + err.message;
        }
      }

      // --- Core Logic ---
      async function runAnalysis() {
        if (!state.sudachi || !state.dictDB) return;
        const text = inputText.value;
        if (!text.trim()) {
          outputDisplay.innerHTML = "";
          return;
        }

        // 1. Tokenize
        const tokens = JSON.parse(state.sudachi.tokenize_stringified(text, 0));

        // 2. Scan for Grammar
        let grammarRanges = [];
        for (const ruleJson of GRAMMAR_RULES) {
          const rule = new GrammarRule(ruleJson);
          const matches = rule.scan(tokens);
          matches.forEach((m) => {
            grammarRanges.push({
              start: m.index,
              end: m.index + m.length,
              data: ruleJson,
              type: "grammar",
            });
          });
        }

        // Resolve grammar overlaps (longest match first)
        grammarRanges.sort(
          (a, b) => b.end - b.start - (a.end - a.start) || a.start - b.start,
        );
        const activeGrammar = [];
        const usedTokens = new Set();
        for (const r of grammarRanges) {
          let conflict = false;
          for (let i = r.start; i < r.end; i++)
            if (usedTokens.has(i)) conflict = true;
          if (!conflict) {
            activeGrammar.push(r);
            for (let i = r.start; i < r.end; i++) usedTokens.add(i);
          }
        }

        // 3. Render
        let html = "";
        for (let i = 0; i < tokens.length; i++) {
          const gMatch = activeGrammar.find((r) => r.start === i);

          if (gMatch) {
            // Render Grammar Block
            let blockContent = "";
            for (let j = gMatch.start; j < gMatch.end; j++) {
              blockContent += generateRuby(
                tokens[j].surface,
                katakanaToHiragana(tokens[j].reading_form),
              );
            }
            html += `<span class="grammar-match" 
                           data-type="grammar"
                           data-title="${gMatch.data.title}" 
                           data-desc="${gMatch.data.description}" 
                           data-link="${gMatch.data.link || "#"}">${blockContent}</span>`;
            i = gMatch.end - 1;
          } else {
            // Check Dictionary for single token
            const token = tokens[i];
            const dictDef = await searchDictionary(token.dictionary_form);
            const content = generateRuby(
              token.surface,
              katakanaToHiragana(token.reading_form),
            );

            if (dictDef) {
              html += `<span class="dict-match" 
                             data-type="dict"
                             data-kanji="${token.dictionary_form}"
                             data-surface="${token.surface}">${content}</span>`;
            } else {
              html += content;
            }
          }
        }
        outputDisplay.innerHTML = html;
      }

      // --- Tooltip Interaction ---
      async function showTooltip(el) {
        console.log("hi");
        const type = el.dataset.type;
        tooltip.style.display = "block";
        tooltip.innerHTML = "Loading...";

        if (type === "grammar") {
          tooltip.innerHTML = `
            <h3>${el.dataset.title}</h3>
            <p>${el.dataset.desc}</p>
            ${el.dataset.link !== "#" ? `<a href="${el.dataset.link}" target="_blank">Check Bunpro &rarr;</a>` : ""}
          `;
        } else {
          const kanji = el.dataset.kanji;
          const defs = await searchDictionary(kanji);
          console.log("defs", defs);
          if (defs) {
            let out = `<h3>${kanji}</h3>`;
            defs.forEach((g) => {
              out += `<div class="entry">${g.info && g.info.length ? `<i>${g.info}</i><br/>` : ""}${g.gloss.join(", ")}
                </div>`;
            });
            out += `<a href="${`https://jotoba.de/search/0/${encodeURIComponent(kanji)}`}" target="_blank">View on Jotoba</a>`;
            tooltip.innerHTML = out;
          }
        }

        const rect = el.getBoundingClientRect();
        tooltip.style.top = `${rect.bottom + window.scrollY + 10}px`;
        tooltip.style.left = `${Math.min(rect.left + window.scrollX, window.innerWidth - 320)}px`;

        el.classList.add("active");
      }

      document.addEventListener("click", (e) => {
        const match = e.target.closest(".grammar-match, .dict-match");
        document
          .querySelectorAll(".active")
          .forEach((el) => el.classList.remove("active"));
        if (match) {
          showTooltip(match);
        } else if (!e.target.closest("#grammar-tooltip")) {
          tooltip.style.display = "none";
        }
      });

      let timeout;
      inputText.addEventListener("input", () => {
        clearTimeout(timeout);
        timeout = setTimeout(runAnalysis, 400);
      });

      initResources();
    </script>
  </body>
</html>
