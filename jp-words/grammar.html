<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Japanese Grammar & Dict Matcher</title>
    <link rel="stylesheet" href="grammar.css" />
  </head>
  <body>
    <h1>Grammar Analyzer</h1>

    <div class="controls-area">
      <div class="button-group">
        <button id="btn-paste">üìã Paste from Clipboard</button>
        <button id="btn-clear" class="clear-btn">‚ùå Clear</button>
      </div>

      <div class="filters-container">
        <!-- Main Options -->
        <div class="options-row">
          <label class="filter-item bold-opt"
            ><input type="checkbox" id="toggle-grammar" checked /> Highlight
            Grammar</label
          >
          <label class="filter-item bold-opt"
            ><input type="checkbox" id="toggle-furigana" checked /> Show
            Furigana</label
          >
        </div>

        <!-- POS Filters -->
        <div class="filters">
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="ÂãïË©û" />
            Verb (ÂãïË©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="Âä©ÂãïË©û" />
            Aux. Verb (Âä©ÂãïË©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="Âä©Ë©û" />
            Particle (Âä©Ë©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="ÂêçË©û" />
            Noun (ÂêçË©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="ÂΩ¢ÂÆπË©û" />
            Adjective (ÂΩ¢ÂÆπË©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="ÂâØË©û" />
            Adverb (ÂâØË©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="ÂΩ¢Áä∂Ë©û" />
            Na-Adj (ÂΩ¢Áä∂Ë©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="‰ª£ÂêçË©û" />
            Pronoun (‰ª£ÂêçË©û)</label
          >
          <label class="filter-item"
            ><input type="checkbox" class="pos-filter" checked value="Êé•Â∞æËæû" />
            Suffix (Êé•Â∞æËæû)</label
          >
        </div>
      </div>
    </div>

    <div class="container">
      <div class="panel">
        <div class="panel-header">Input Japanese</div>
        <textarea id="input-text"> </textarea>
      </div>
      <div class="panel">
        <div class="panel-header">Analysis (Hover words for details)</div>
        <div id="output-display"></div>
        <div class="status-bar" id="status-bar">Initializing...</div>
      </div>
    </div>
    <div id="grammar-tooltip"><div class="tooltip-content"></div></div>
    <script type="module">
      import { GrammarRule } from "./grammar-engine.js";
      import {
        VerbTenseDetector,
        POS_LABEL_MAP,
        JMDICT_POS_MAP,
        JMDICT_TAG_MAP,
        SAMPLE_SENTENCES,
      } from "./conjugations.js";
      import GRAMMAR_RULES from "./grammar-rules.js";
      import { SudachiStateless } from "./sudachi-wasm/sudachi.js";

      const inputText = document.getElementById("input-text");
      inputText.innerHTML = SAMPLE_SENTENCES;
      const outputDisplay = document.getElementById("output-display");
      const statusBar = document.getElementById("status-bar");
      const tooltip = document.getElementById("grammar-tooltip");
      const tooltipContent = tooltip.querySelector(".tooltip-content");

      const filterInputs = document.querySelectorAll(".pos-filter");
      const toggleGrammar = document.getElementById("toggle-grammar");
      const toggleFurigana = document.getElementById("toggle-furigana");

      const btnPaste = document.getElementById("btn-paste");
      const btnClear = document.getElementById("btn-clear");

      // Initialize the VerbTenseDetector
      const tenseDetector = new VerbTenseDetector();
      window.tenseDetector = tenseDetector;
      let state = { sudachi: null, dictDB: null };
      window.state = state;

      async function fetchAndGunzip(url) {
        const response = await fetch(url);
        const ds = new DecompressionStream("gzip");
        const stream = response.body.pipeThrough(ds);
        return await new Response(stream).blob();
      }

      function katakanaToHiragana(src) {
        return src.replace(/[\u30a1-\u30f6]/g, (m) =>
          String.fromCharCode(m.charCodeAt(0) - 0x60),
        );
      }

      function generateRuby(surface, reading) {
        if (!reading || surface === reading || !/[\u4e00-\u9faf]/.test(surface))
          return surface;

        let sEnd = surface.length,
          rEnd = reading.length;
        while (
          sEnd > 0 &&
          rEnd > 0 &&
          surface[sEnd - 1] === reading[rEnd - 1]
        ) {
          sEnd--;
          rEnd--;
        }

        let sStart = 0,
          rStart = 0;
        while (
          sStart < sEnd &&
          rStart < rEnd &&
          surface[sStart] === reading[rStart]
        ) {
          sStart++;
          rStart++;
        }

        const prefix = surface.substring(0, sStart);
        const suffix = surface.substring(sEnd);
        const coreS = surface.substring(sStart, sEnd);
        const coreR = reading.substring(rStart, rEnd);

        return coreS
          ? `${prefix}<ruby>${coreS}<rt>${coreR}</rt></ruby>${suffix}`
          : surface;
      }

      function getReadingFromSudachi(text) {
        if (!state.sudachi || !text) return "";
        try {
          const raw = state.sudachi.tokenize_stringified(text, 0);
          const tokens = JSON.parse(raw);
          return tokens.map((t) => katakanaToHiragana(t.reading_form)).join("");
        } catch (e) {
          return "";
        }
      }

      function getPos(token) {
        const p = token.poses || token.pos;
        return p && p.length > 0 ? p[0] : "Unk";
      }

      // Helper to determine if a token should be grouped with the preceding Verb/Adj
      // Includes Auxiliaries, Suffixes, and Conjunctive Particles („Å¶, „Åß, „Å∞).
      function shouldGroup(token) {
        const p = token.poses || token.pos;
        if (!p || p.length === 0) return false;
        const pos0 = p[0];

        if (pos0 === "Âä©ÂãïË©û" || pos0 === "Êé•Â∞æËæû") return true;
        // Sudachi structure for Conjunctive Particle: ['Âä©Ë©û', 'Êé•Á∂öÂä©Ë©û', '*', '*']
        if (pos0 === "Âä©Ë©û" && p.length > 1 && p[1] === "Êé•Á∂öÂä©Ë©û") return true;

        return false;
      }

      function searchDictionary(term, sudachiPos) {
        if (!state.dictDB) return null;
        let indices = state.dictDB.index[term];
        if (!indices && term.length > 1) {
          indices = state.dictDB.index[term.slice(0, -1)];
        }
        if (!indices) {
          return null;
        }

        const entries = indices.map((idx) => state.dictDB.defs[idx]);
        if (sudachiPos && JMDICT_POS_MAP[sudachiPos]) {
          const allowedCodes = new Set(JMDICT_POS_MAP[sudachiPos]);
          const filteredEntries = [];
          for (const entrySenses of entries) {
            const validSenses = entrySenses.filter((sense) => {
              if (!sense.partOfSpeech || sense.partOfSpeech.length === 0)
                return true;
              return sense.partOfSpeech.some((code) => allowedCodes.has(code));
            });
            if (validSenses.length > 0) filteredEntries.push(validSenses);
          }
          return filteredEntries.length > 0 ? filteredEntries : null;
        }
        return entries;
      }

      function generateDictHTML(
        surface,
        dictForm,
        reading,
        pos,
        entryGroups,
        tenseData = null,
      ) {
        if (!entryGroups || entryGroups.length === 0) return "";

        let out = `<div class="dict-header-container">`;

        // Left Side: Word (Surface) + Badges
        out += `<div class="dict-header-left">`;
        // Title uses Surface form and reading
        const titleHtml = generateRuby(surface, reading);
        out += `<h3>${titleHtml}</h3>`;

        // Badges: English POS + Dict Form
        out += `<div class="badge-container">`;

        const englishPos = POS_LABEL_MAP[pos] || pos;
        if (englishPos) out += `<span class="pos-badge">${englishPos}</span>`;

        if (dictForm && dictForm !== surface) {
          out += `<span class="pos-badge dict-ref">Dict: ${dictForm}</span>`;
        }
        out += `</div>`; // End Badge Container

        out += `</div>`; // End Left

        // Right Side: Conjugation Info
        if (tenseData && tenseData.length > 0) {
          out += `<div class="dict-header-right"><div class="conjugation-group">`;
          tenseData.forEach((t) => {
            out += `<div class="conjugation-item">
                    <span class="conjugation-tag">${t.name}</span>
                    <span class="conjugation-desc">${t.description}</span>
                  </div>`;
          });
          out += `</div></div>`; // End Right
        }

        out += `</div>`; // End Container

        // Definitions
        entryGroups.forEach((senses, index) => {
          out += `<div class="dict-entry-group">`;
          if (entryGroups.length > 1) out += `<h4>Entry ${index + 1}</h4>`;
          senses.forEach((sense) => {
            const decodedPos =
              sense.partOfSpeech && sense.partOfSpeech.length
                ? sense.partOfSpeech
                    .map((code) => JMDICT_TAG_MAP[code] || code)
                    .join(", ")
                : "";

            out += `<div class="entry">
                ${decodedPos ? `<span class="pos-tag-decoded">[${decodedPos}]</span><br/>` : ""}
                ${sense.info && sense.info.length ? `<span style="color:#e67e22; font-size:0.9em;">[${sense.info.join(", ")}]</span><br/>` : ""}
                ${sense.gloss.join(", ")}
              </div>`;
          });
          out += `</div>`;
        });

        out += `<a class="ext-link" href="${`https://jotoba.de/search/0/${encodeURIComponent(dictForm)}`}" target="_blank">View on Jotoba</a>`;
        return out;
      }

      function renderTokenOrGroup(item, activePOS) {
        let content = "";
        let pos = "";
        let dictForm = "";
        let normForm = "";
        let surface = "";
        let tenseAttr = "";

        if (item.isGroup) {
          content = item.tokens
            .map((t) =>
              generateRuby(t.surface, katakanaToHiragana(t.reading_form)),
            )
            .join("");
          const head = item.baseToken;
          pos = getPos(head);
          dictForm = head.dictionary_form;
          normForm = head.normalized_form;
          surface = item.surface;
        } else {
          content = generateRuby(
            item.surface,
            katakanaToHiragana(item.reading_form),
          );
          pos = getPos(item);
          dictForm = item.dictionary_form;
          normForm = item.normalized_form;
          surface = item.surface;
        }

        if (pos === "ÂãïË©û") {
          const matches = tenseDetector.detect(dictForm, surface);
          if (matches && matches.length > 0) {
            tenseAttr = `data-tense="${encodeURIComponent(JSON.stringify(matches))}"`;
          }
        }

        if (activePOS.has(pos)) {
          let compatibleEntries = searchDictionary(dictForm, pos);
          let finalForm = dictForm;

          if (!compatibleEntries && normForm && normForm !== dictForm) {
            const normEntries = searchDictionary(normForm, pos);
            if (normEntries) {
              compatibleEntries = normEntries;
              finalForm = normForm;
            }
          }

          if (compatibleEntries) {
            return `<span class="dict-match" 
                           data-type="dict"
                           data-kanji="${finalForm}"
                           data-surface="${surface}"
                           data-pos="${pos}"
                           ${tenseAttr}>${content}</span>`;
          }
        }
        return content;
      }

      async function initResources() {
        try {
          statusBar.innerText = "Loading Sudachi...";
          const dictBlob = await fetchAndGunzip(
            "sudachi-wasm/resources/system.dic.gz",
          );
          state.sudachi = new SudachiStateless();
          await state.sudachi.initialize_from_bytes(
            new Uint8Array(await dictBlob.arrayBuffer()),
          );

          statusBar.innerText = "Loading Dictionary...";
          const jpDictBlob = await fetchAndGunzip("jpdict.json.gz");
          state.dictDB = JSON.parse(await jpDictBlob.text());

          statusBar.innerText = "Ready";
          runAnalysis();
        } catch (err) {
          statusBar.innerText = "Error: " + err.message;
          console.error(err);
        }
      }

      async function runAnalysis() {
        if (!state.sudachi || !state.dictDB) return;
        const text = inputText.value;
        if (!text.trim()) {
          outputDisplay.innerHTML = "";
          return;
        }

        const activePOS = new Set();
        filterInputs.forEach((input) => {
          if (input.checked) activePOS.add(input.value);
        });
        const isGrammarEnabled = toggleGrammar.checked;

        const rawTokens = JSON.parse(
          state.sudachi.tokenize_stringified(text, 0),
        );

        let activeGrammar = [];
        if (isGrammarEnabled) {
          let grammarRanges = [];
          for (const ruleJson of GRAMMAR_RULES) {
            const rule = new GrammarRule(ruleJson);
            const matches = rule.scan(rawTokens);
            matches.forEach((m) => {
              grammarRanges.push({
                start: m.index,
                end: m.index + m.length,
                data: ruleJson,
              });
            });
          }
          grammarRanges.sort(
            (a, b) => b.end - b.start - (a.end - a.start) || a.start - b.start,
          );

          const usedTokens = new Set();
          for (const r of grammarRanges) {
            let conflict = false;
            for (let i = r.start; i < r.end; i++)
              if (usedTokens.has(i)) conflict = true;
            if (!conflict) {
              activeGrammar.push(r);
              for (let i = r.start; i < r.end; i++) usedTokens.add(i);
            }
          }

          // Extend grammar match to include trailing conjugations
          for (const match of activeGrammar) {
            let nextIdx = match.end;
            while (nextIdx < rawTokens.length) {
              if (activeGrammar.some((other) => other.start === nextIdx)) break;
              const nextToken = rawTokens[nextIdx];
              if (shouldGroup(nextToken)) {
                match.end++;
                nextIdx++;
              } else {
                break;
              }
            }
          }
        }

        let html = "";
        let i = 0;

        while (i < rawTokens.length) {
          const gMatch = activeGrammar.find((r) => r.start === i);
          if (gMatch) {
            let blockContent = "";
            let innerWords = [];
            let seenInner = new Set();

            for (let j = gMatch.start; j < gMatch.end; j++) {
              const t = rawTokens[j];
              const tPos = getPos(t);

              blockContent += generateRuby(
                t.surface,
                katakanaToHiragana(t.reading_form),
              );

              // -------------------------------------------------------------
              // LOGIC UPDATE:
              // Inside a grammar match, the surface form of a content word
              // is extended to the end of the match.
              // e.g. "È£ü„Åπ„Å¶„ÅÑ„Åæ„Åô": "È£ü„Åπ" (Verb) -> surface becomes "È£ü„Åπ„Å¶„ÅÑ„Åæ„Åô"
              // -------------------------------------------------------------

              if (
                ["ÂãïË©û", "ÂΩ¢ÂÆπË©û", "ÂΩ¢Áä∂Ë©û", "ÂêçË©û"].includes(tPos) &&
                t.dictionary_form
              ) {
                let compoundSurface = t.surface;
                // Accumulate all remaining surfaces in the grammar match
                for (let k = j + 1; k < gMatch.end; k++) {
                  compoundSurface += rawTokens[k].surface;
                }

                let validForm = t.dictionary_form;
                if (!searchDictionary(validForm, tPos) && t.normalized_form) {
                  if (searchDictionary(t.normalized_form, tPos)) {
                    validForm = t.normalized_form;
                  }
                }

                // Check for conjugation on this EXTENDED token group
                let tenseMatches = [];
                if (tPos === "ÂãïË©û") {
                  tenseMatches = tenseDetector.detect(
                    validForm,
                    compoundSurface,
                  );
                }

                if (!seenInner.has(validForm)) {
                  seenInner.add(validForm);
                  innerWords.push({
                    kanji: validForm, // Dictionary form
                    surface: compoundSurface, // FULL Extended Surface form
                    pos: tPos,
                    tense: tenseMatches,
                  });
                }
              }
            }

            const innerJson =
              innerWords.length > 0
                ? encodeURIComponent(JSON.stringify(innerWords))
                : "";

            html += `<span class="grammar-match" 
                           data-type="grammar"
                           data-title="${gMatch.data.title}" 
                           data-desc="${gMatch.data.description}" 
                           data-link="${gMatch.data.link || "#"}"
                           data-inner-defs="${innerJson}">${blockContent}</span>`;
            i = gMatch.end;
            continue;
          }

          // Standard Token Rendering
          const current = rawTokens[i];
          const pos = getPos(current);

          if (pos === "ÂãïË©û" || pos === "ÂΩ¢ÂÆπË©û" || pos === "ÂΩ¢Áä∂Ë©û") {
            let groupTokens = [current];
            let nextIndex = i + 1;
            while (nextIndex < rawTokens.length) {
              if (activeGrammar.some((r) => r.start === nextIndex)) break;
              const nextToken = rawTokens[nextIndex];
              if (shouldGroup(nextToken)) {
                groupTokens.push(nextToken);
                nextIndex++;
              } else {
                break;
              }
            }
            const groupObj = {
              isGroup: true,
              tokens: groupTokens,
              baseToken: current,
              surface: groupTokens.map((t) => t.surface).join(""),
            };
            html += renderTokenOrGroup(groupObj, activePOS);
            i = nextIndex;
          } else {
            html += renderTokenOrGroup(current, activePOS);
            i++;
          }
        }
        outputDisplay.innerHTML = html;
      }

      let hoverTimeout;
      let activeElement = null;

      async function showTooltip(el) {
        const type = el.dataset.type;
        tooltip.style.display = "block";
        tooltipContent.innerHTML = "Loading...";

        const rect = el.getBoundingClientRect();
        const tooltipWidth = 320;
        let top = window.scrollY + rect.bottom + 5;
        let left = window.scrollX + rect.left;

        if (left + tooltipWidth > window.innerWidth + window.scrollX) {
          left = window.innerWidth + window.scrollX - tooltipWidth - 20;
        }
        if (left < 10) left = 10;

        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;

        if (type === "grammar") {
          let content = `
            <div class="grammar-section">
                <h3>${el.dataset.title}</h3>
                <p>${el.dataset.desc}</p>
                ${el.dataset.link !== "#" ? `<a class="ext-link" href="${el.dataset.link}" target="_blank">Check Bunpro &rarr;</a>` : ""}
            </div>
          `;

          if (el.dataset.innerDefs) {
            try {
              const innerDefs = JSON.parse(
                decodeURIComponent(el.dataset.innerDefs),
              );
              let hasDict = false;

              for (const word of innerDefs) {
                const entryGroups = searchDictionary(word.kanji, word.pos);
                if (entryGroups) {
                  if (!hasDict) {
                    content += `<div class="embedded-dict-header">Words in this pattern:</div>`;
                    hasDict = true;
                  }

                  // Get reading for the Surface form.
                  // Since word.surface is now the full grammar string (e.g. "È£ü„Åπ„Å¶„ÅÑ„Åæ„Åô"),
                  // this will generate the correct reading for the whole string.
                  const reading = getReadingFromSudachi(
                    word.surface || word.kanji,
                  );

                  content += `<div class="embedded-dict-section">`;
                  content += generateDictHTML(
                    word.surface || word.kanji,
                    word.kanji,
                    reading,
                    word.pos,
                    entryGroups,
                    word.tense,
                  );
                  content += `</div>`;
                }
              }
            } catch (e) {
              console.error("Failed to parse inner defs", e);
            }
          }

          tooltipContent.innerHTML = content;
        } else {
          // Standard Dictionary Match
          const dictForm = el.dataset.kanji;
          const surface = el.dataset.surface;
          const pos = el.dataset.pos;
          const entryGroups = searchDictionary(dictForm, pos);

          if (activeElement !== el) return;

          let contentHtml = "";
          let tenseData = null;

          if (el.dataset.tense) {
            try {
              tenseData = JSON.parse(decodeURIComponent(el.dataset.tense));
            } catch (e) {
              console.error("Failed to parse tense data", e);
            }
          }

          if (entryGroups && entryGroups.length > 0) {
            const reading = getReadingFromSudachi(surface);
            contentHtml += generateDictHTML(
              surface,
              dictForm,
              reading,
              pos,
              entryGroups,
              tenseData,
            );
          } else {
            contentHtml += "No definitions found matching this part of speech.";
          }

          tooltipContent.innerHTML = contentHtml;
        }
      }

      function hideTooltip() {
        tooltip.style.display = "none";
        if (activeElement) {
          activeElement.classList.remove("active");
          activeElement = null;
        }
      }

      function scheduleHide() {
        if (hoverTimeout) clearTimeout(hoverTimeout);
        hoverTimeout = setTimeout(hideTooltip, 200);
      }

      function cancelHide() {
        if (hoverTimeout) {
          clearTimeout(hoverTimeout);
          hoverTimeout = null;
        }
      }

      outputDisplay.addEventListener("mouseover", (e) => {
        const match = e.target.closest(".grammar-match, .dict-match");
        if (match) {
          cancelHide();
          if (activeElement !== match) {
            if (activeElement) activeElement.classList.remove("active");
            activeElement = match;
            activeElement.classList.add("active");
            showTooltip(match);
          }
        }
      });

      outputDisplay.addEventListener("mouseout", (e) => {
        const match = e.target.closest(".grammar-match, .dict-match");
        if (match) {
          if (e.relatedTarget && match.contains(e.relatedTarget)) return;
          scheduleHide();
        }
      });

      tooltip.addEventListener("mouseenter", cancelHide);
      tooltip.addEventListener("mouseleave", scheduleHide);

      btnPaste.addEventListener("click", async () => {
        try {
          const text = await navigator.clipboard.readText();
          inputText.value = text;
          runAnalysis();
        } catch (err) {
          alert("Failed to read clipboard contents: " + err);
        }
      });

      btnClear.addEventListener("click", () => {
        inputText.value = "";
        runAnalysis();
      });

      const allToggles = [...filterInputs, toggleGrammar];
      allToggles.forEach((input) => {
        input.addEventListener("change", runAnalysis);
      });

      toggleFurigana.addEventListener("change", (e) => {
        if (e.target.checked) document.body.classList.remove("hide-furigana");
        else document.body.classList.add("hide-furigana");
      });

      let timeout;
      inputText.addEventListener("input", () => {
        clearTimeout(timeout);
        timeout = setTimeout(runAnalysis, 400);
      });

      initResources();
    </script>
  </body>
</html>
