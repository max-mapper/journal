<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Japanese Grammar Matcher Demo</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f4f9;
        color: #333;
      }

      h1 {
        color: #2c3e50;
      }

      .container {
        display: flex;
        gap: 20px;
        max-width: 1200px;
        margin: 0 auto;
        height: 80vh;
      }

      .panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .panel-header {
        padding: 15px;
        background: #eee;
        border-bottom: 1px solid #ddd;
        font-weight: bold;
      }

      textarea {
        flex: 1;
        border: none;
        padding: 15px;
        font-size: 18px;
        line-height: 1.6;
        resize: none;
        outline: none;
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
      }

      #output-display {
        flex: 1;
        padding: 15px;
        font-size: 18px;
        line-height: 1.6;
        overflow-y: auto;
        white-space: pre-wrap; /* Preserve newlines */
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
      }

      /* Grammar Highlight Styles */
      .grammar-match {
        background-color: #e3f2fd;
        border-bottom: 2px solid #2196f3;
        cursor: pointer;
        position: relative;
        transition: background 0.2s;
        border-radius: 3px;
      }

      .grammar-match:hover {
        background-color: #bbdefb;
      }

      /* Tooltip via CSS */
      .grammar-match::after {
        content: attr(data-rule);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: #fff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition:
          opacity 0.2s,
          bottom 0.2s;
        margin-bottom: 5px;
        z-index: 10;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .grammar-match:hover::after {
        opacity: 1;
        bottom: 100%; /* Ensure it sits above */
      }

      /* Little arrow for the tooltip */
      .grammar-match:hover::before {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: #333 transparent transparent transparent;
        margin-bottom: -5px; /* Offset to connect to box */
      }

      .status-bar {
        padding: 10px;
        background: #2c3e50;
        color: white;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <!-- <div id="loader">Initializing Sudachi (this may take a moment)...</div> -->

    <h1>ğŸ‡¯ğŸ‡µ Grammar Analyzer</h1>

    <div class="container">
      <!-- Input Section -->
      <div class="panel">
        <div class="panel-header">Input Japanese Text</div>
        <textarea
          id="input-text"
          placeholder="ã“ã“ã«æ—¥æœ¬èªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."
        >
ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’å‹é”ã«ã‚ã’ã¾ã™ã€‚
æ˜æ—¥ã¯é›¨ãŒãµã‚‹ã¨æ€ã„ã¾ã™ã€‚
ãƒ‘ãƒ³ã‚’é£Ÿã¹ã¾ã—ãŸã€‚ãŠè…¹ãŒç©ºã„ãŸã‹ã‚‰ã§ã™ã€‚
ã‚¢ãƒ¡ãƒªã‚«ã‹ã‚‰æ¥ã¾ã—ãŸã€‚
ä½•äººãã‚‰ã„æ¥ã¾ã™ã‹ã€‚
å‹é”ãŒç§ã«ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’ãã‚Œã¾ã—ãŸã€‚
æ—¥æœ¬èªã®æ£®ã§åƒããŸã„ã§ã™ã€‚
ã“ã“ã®ãƒ‘ã‚½ã‚³ãƒ³ã¯å­¦ç”Ÿã ã‘ãŒä½¿ãˆã¾ã™ã€‚
å¤§å­¦ã«è¡Œãã¤ã‚‚ã‚Šã§ã™ã€‚
ã“ã‚Œã‹ã‚‰åœ°çƒã®æ¸©åº¦ãŒã ã‚“ã ã‚“é«˜ããªã£ã¦ã„ãã€‚
ä»Šã€æœã”ã¯ã‚“ã‚’é£Ÿã¹ã¦ã„ã¾ã™ã€‚
å…ˆç”Ÿã«èã„ã¦ãã ã•ã„ã€‚
ä»–ã®äººã‚’å‚·ã¤ã‘ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚
ä»•äº‹ã¯å¿™ã—ã„ã§ã™ã€‚ã§ã‚‚ã€æ¥½ã—ã„ã§ã™ã€‚
å¸°ã£ã¦ã‚‚ã„ã„ã§ã™ã‹ã€‚
ã“ã“ã«æ¥ã¦ãã ã•ã„ã€‚
å®¿é¡Œã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ã€‚
ã‚¸ãƒ¥ãƒ›ã•ã‚“ã¯éŸ“å›½äººã˜ã‚ƒãªã„ã§ã™ã‹ã€‚
å¤§äººã«ãªã‚Šã¾ã—ãŸã€‚
ã‚²ãƒ¼ãƒ ã‚’ã—ã¾ã—ã‚‡ã†ã€‚
ã‚«ãƒ•ã‚§ã«è¡Œãã¾ã—ã‚‡ã†ã‹ã€‚
ãƒ†ãƒ¬ãƒ“ã‚’è¦‹ã¾ã›ã‚“ã‹ã€‚
æˆæ¥­ã¯4æ™‚ã¾ã§ã§ã™ã€‚
ç§ã¯å‹é”ã«ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’ã‚‚ã‚‰ã„ã¾ã—ãŸã€‚
ãƒ†ã‚¹ãƒˆã®å‰ã«å‹‰å¼·ã—ã¾ã™ã€‚
æˆæ¥­ã®å¾Œã§å¸°ã‚Šã¾ã—ãŸã€‚
ã“ã®æ¼¢å­—ã®èª­ã¿æ–¹ã¯ä½•ã§ã™ã‹ã€‚
ãŸãã•ã‚“æœ¬ãŒã‚ã‚Šã¾ã™ã€‚
æœ9æ™‚ã«èµ·ãã¾ã—ãŸã€‚
æ˜ ç”»ã‚’è¦‹ã‚‹ã“ã¨ãŒå¥½ãã§ã™ã€‚
è¨€ã„é–“é•ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
å½¼ã¯å‹é”ã‚’ã†ã‚‰ãã‚‹ã“ã¨ã¯ãªã„ã€‚
çŒ«ã¨çŠ¬ãŒå¥½ãã ã€‚
ãŠèŒ¶ã¨æ°´ã¨ã€ã©ã¡ã‚‰ãŒã„ã„ã§ã™ã‹ã€‚
ãƒ•ã‚¡ãƒŸãƒªãƒ¼ãƒãƒ¼ãƒˆã¨ã„ã†ã‚³ãƒ³ãƒ“ãƒ‹ã‚’çŸ¥ã£ã¦ã„ã¾ã™ã‹ã€‚
ã‚¿ãƒ©ã¨è¨€ã„ã¾ã™ã€‚
7æ™‚ã«èµ·ãã¾ã™ã€‚
æ–°å®¿ã¯æ±äº¬ã«ã‚ã‚‹ã€‚
æ—¥æœ¬ã«åƒãã«æ¥ãŸã€‚
ã“ã‚Œã¯ãƒšãƒ³ã§ã™ã€‚
ã‚†ã‹ã•ã‚“ã¯å…ˆç”Ÿã§ã™ã€‚
ä»Šã‹ã‚‰ä¼‘æ†©ãŒå§‹ã¾ã‚Šã¾ã™ã€‚
æ˜¨æ—¥4æ™‚ã«å¸°ã‚Šã¾ã—ãŸã€‚
çŒ«ã¯ã‹ã‚ã„ã„ã€‚
ä»Šæ—¥å‹‰å¼·ã—ãŸã‚Šã€è²·ã„ç‰©ã‚’ã—ãŸã‚Šã—ã¾ã—ãŸã€‚
èª•ç”Ÿæ—¥ã¯ã„ã¤ã§ã™ã‹ã€‚
å›³æ›¸é¤¨ã§å‹‰å¼·ã—ã¾ã™ã€‚
ãƒœãƒ¼ãƒ«ã‚’è½ã¨ã—ãŸã€‚
æ–°å®¿ã¸è¡Œãã¾ã™ã€‚
èª°ãŒé–¢è¥¿å‡ºèº«ã§ã™ã‹ã€‚
å…„å¼Ÿã¨ã‚ˆãã‘ã‚“ã‹ã—ã¾ã™ã€‚
ã“ã‚Œã¯ç§ã®ãƒšãƒ³ã ã€‚
ç§ã‚‚å­¦ç”Ÿã§ã™ã€‚
ç‰›ä¹³ã‚„åµã‚’è²·ã„ã¾ã—ãŸã€‚
1æ™‚ã”ã‚ä¼šè­°ãŒã‚ã‚Šã¾ã™ã€‚
æ—¥æœ¬ã«å¥½ããªé£Ÿã¹ç‰©ãŒã‚ã¾ã‚Šãªã„ã€‚
é­šã¯ãœã‚“ãœã‚“å¥½ãã˜ã‚ƒãªã„ã€‚
æœ¬ã‚’3å†Šè²·ã„ã¾ã™ã€‚
ã“ã®ãƒšãƒ³ã¯é’ã„ã€‚
å®¶ã¯éƒµä¾¿å±€ã®å³ã«ã‚ã‚Šã¾ã™ã€‚
å½¼ã¯èƒŒãŒé«˜ã„ã§ã™ã€‚
æ­Œã†ã®ãŒå¥½ãã§ã™ã€‚
ä¸Šç”°ãã‚“ã¯å“çƒãŒä¸Šæ‰‹ã ã€‚
å»Šä¸‹ã‚’é™ã‹ã«æ­©ã„ãŸã€‚
æ—¥æœ¬ã¨ã‚¢ãƒ¡ãƒªã‚«ã¨ã€ã©ã¡ã‚‰ã®ã»ã†ãŒå¤§ãã„ï¼Ÿ
ã‚¢ãƒ¡ãƒªã‚«ã¯æ—¥æœ¬ã‚ˆã‚Šå¤§ãã„ã§ã™ã€‚
é£Ÿã¹ç‰©ã®ä¸­ã§ã€ãƒ‘ãƒ³ãŒä¸€ç•ªãŠã„ã—ã„ã§ã™ã€‚
æ˜æ—¥é›¨ãŒãµã‚‹ã§ã—ã‚‡ã†ã€‚
éƒ½ä¼šã¯ã†ã‚‹ã•ã™ãã‚‹ã€‚
ãŠé‡‘ãŒã»ã—ã„ã§ã™ã€‚
æ°´ã‚’ãã ã•ã„ã€‚
å®¶ã«å¸°ã£ã¦ã€ã‚·ãƒ£ãƒ¯ãƒ¼ã‚’æµ´ã³ã¾ã—ãŸã€‚
å­¦ç”Ÿã§ã€æ—¥æœ¬ã«ä½ã‚“ã§ã„ã‚‹ã€‚
ã¾ã å®¶ã‹ã‚‰å‡ºã¦ã„ãªã„ã§ã™ã€‚
å½¼ã¯ã‚‚ã†å¸°ã‚Šã¾ã—ãŸã€‚
å®¿é¡Œã‚’ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ã‚³ãƒ¼ãƒ’ãƒ¼ã˜ã‚ƒãªãã¦ãŠèŒ¶ã‚’ãã ã•ã„ã€‚
æ—¥æœ¬èªã‚’å‹‰å¼·ã™ã‚‹ã€‚
æ¯ãŒãã‚ŒãŸæ™‚è¨ˆã¯å¤ã„ã§ã™ã€‚
å†·è”µåº«ã«ä½•ã‚‚ãªã„ã§ã™ã€‚

é¶è‚‰ã¯ã‚ã¾ã‚Šå¥½ãã˜ã‚ƒãªã„ã€‚
ä»•äº‹ãŒçµ‚ã‚ã£ãŸã‚ã¨ã§ã€ã‚¸ãƒ ã«è¡Œãã€‚
ã‚ãªãŸãŒè¡Œã‘ã°ã€ç§ã‚‚è¡Œãã¾ã™ã€‚
é›¨ãŒé™ã‚‰ãªã„å ´åˆã¯æ³³ãã¾ã™ã€‚
äºŒäººã ã‘ã§å°‘ã—è©±ãŒã—ãŸã„ã€‚
é›¨ãŒé™ã‚Šã ã—ãŸã€‚
æš‡ã ã‹ã‚‰ã€ã‚²ãƒ¼ãƒ ã§ã‚‚ã—ã¾ã—ã‚‡ã†ã€‚
ã“ã®çŒ«ã¯èª°ã‚‚æ¬²ã—ãŒã‚‹äººãŒã„ãªã‹ã£ãŸã€‚
æ—¥æœ¬èªã‚’å‹‰å¼·ã—å§‹ã‚ã¦ã€ã‚‚ã†å››å¹´çµŒã£ãŸã€‚
ãã®èˆ¹ã¯æ²ˆã‚€ã¯ãšãŒãªã„ã€‚
é£Ÿã¹ç‰©ãŒå¿…è¦ã§ã™ã€‚
é£Ÿã¹ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ç¾å‘³ã—ã„æ™©ã”ã¯ã‚“ãŒæ¬²ã—ã„ã€‚
ã“ã®ã‚²ãƒ¼ãƒ ã¯é›£ã—ã„ã‚“ã˜ã‚ƒãªã„ã‹ã€‚
å½¼ãŒé©šãã‹ã©ã†ã‹ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚
æ¼«ç”»ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
å¯¿å¸ã®é£Ÿã¹æ–¹ã‚’æ•™ãˆã¦ãã‚Œã¾ã›ã‚“ã‹ã€‚
æœ‰åäººã˜ã‚ƒãªã„ã‹ã—ã‚‰ï¼Ÿ
å­ä¾›ã¿ãŸã„ã§ã™ã€‚
ãƒ†ãƒ¬ãƒ“ã‚’è¦‹ãªãŒã‚‰æ™©ã”ã¯ã‚“ã‚’é£Ÿã¹ã¾ã™ã€‚
å¯ãªã„ã§å‹‰å¼·ã‚’ã—ã¾ã™ã€‚
å‹‰å¼·ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
å­¦æ ¡ã«è¡Œã‹ãªãã¦ã‚‚ã„ã„ã€‚
æ—¥æœ¬èªã‚’ç¿’ã„ãŸã„ã®ãªã‚‰ã€ã“ã®æœ¬ãŒã„ã„ã§ã™ã‚ˆã€‚
ã¡ã‚‡ã£ã¨å¾…ã¡ãªã•ã„ã€‚
ãŠæ¯ã•ã‚“ãŒå¸°ã£ã¦ããŸã“ã¨ã«æ°—ãŒã¤ãã€‚
ã“ã®è³ªå•ã«ã¯ç­”ãˆã«ãã„ã§ã™ã€‚
è¨€èªã®ä¸­ã§æ—¥æœ¬èªãŒä¸€ç•ªé›£ã—ã„ã¨æ€ã„ã¾ã™ã€‚
ã”ã¯ã‚“ã‚’ä½œã‚‹ã®ã«ä¸€æ™‚é–“ã‹ã‹ã‚Šã¾ã™ã€‚
ã“ã®ä»•äº‹ã¯ç§ãŒã„ãŸã—ã¾ã™ã€‚
çš†ãŒå­ä¾›ã®ã‚ˆã†ã«å…ƒæ°—ã«æ­Œã„å§‹ã‚ãŸã€‚
ï¼•ãƒ¡ãƒ¼ãƒˆãƒ«ãŠãã«æœ¨ã‚’æ¤ãˆã¾ã—ãŸã€‚
ã‚¿ãƒã‚³ã‚’æ­¢ã‚ã‚‰ã‚Œãªã„ã€‚
å¦¹ãŒéƒ¨å±‹ã«ã„ãªã„ã‚‰ã—ã„ã€‚
ä»Šå¹´ã®æš‘ã•ã¯æ™®é€šã§ã¯ãªã„ã€‚
æ¯ã¯ç§ã«è‡ªåˆ†ã®éƒ¨å±‹ã‚’ç‰‡ä»˜ã‘ã•ã›ãŸã€‚
æ¯æ—¥æ¯ã«é‡èœã‚’é£Ÿã¹ã•ã›ã‚‰ã‚Œã‚‹ã€‚
ã•ã™ãŒã®å½¼ã‚‚å¦»ã«ã¯å‹ã¦ãªã‹ã£ãŸã€‚
ç®±ã®ä¸­ã«åµã¯ä¸€å€‹ã—ã‹æ®‹ã£ã¦ã„ãªã„ã€‚
æ—¥æœ¬ã«æ¥ãŸã°ã‹ã‚Šã§ã™ã€‚
å¦¹ã¯ãã®é¦¬ã«ä¹—ã‚ŠãŸãŒã£ã¦ã„ã‚‹ã€‚
å¯‚ã—ã‹ã£ãŸã‚‰é›»è©±ã‚’ãã ã•ã„ã€‚
å®¿é¡Œã‚’ã—ãŸã‚‰ã©ã†ã§ã™ã‹ã€‚
ã‚ãªãŸã®ã“ã¨ã‚’è©±ã—ã¦ãŸã¨ã“ã‚ã ã‚ˆã€‚
æ˜æ—¥äº‹å‹™æ‰€ã«è¡Œã£ã¦ã»ã—ã„ã€‚
ç§ã¯ä»Šã€å®¶ã§æ—¥æœ¬èªã‚’å‹‰å¼·ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã™ã€‚
ã“ã®ã‚µãƒ©ãƒ€ãŒã™ã”ãç¾å‘³ã—ã„ã‚ˆã€‚é£Ÿã¹ã¦ã¿ã¦ã€‚
é›¨ã§ã‚‚è¡Œãã¾ã—ã‚‡ã†ã€‚
ã“ã®æ–‡ç« ã¯é‡è¦ã§ã™ã€‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚
å›ã«ä¼šãˆã¦ã‚ˆã‹ã£ãŸã€‚
æ—¥æœ¬èªã¯æœ€ã‚‚é›£ã—ã„è¨€èªã ã¨è¨€ã‚ã‚Œã¦ã„ã‚‹ã€‚
ãã®è¾ºã‚Šã¯ã¨ã¦ã‚‚è³‘ã‚„ã‹ã ã¨èã„ãŸã€‚
ã“ã‚Œã‹ã‚‰ãƒ‘ãƒ³ã‚’ç„¼ãã¨ã“ã‚ã§ã™ã€‚
ä»•äº‹ã‚’ç¶šã‘ã‚‹ã®ã¯ç„¡ç†ã ã¨æ€ã†ã€‚
ä¸€æ—¥ä¸­é›¨ãŒé™ã‚Šç¶šãã€‚
å»ºç‰©ã®ä¸­ã¯ã„ã¤ã‚‚ã‚ˆã‚Šæš—ã‹ã£ãŸã€‚
ç§ã¯ç•™å­¦ã‚’ã™ã‚‹äºˆå®šã§ã™ã€‚
ï¼•å¹´é–“æ—¥æœ¬èªã‚’å‹‰å¼·ã—ã¦ã€æ—¥æœ¬èªãŒè©±ã›ã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚
ãã®ã“ã¨ã¯å…¨ç„¶çŸ¥ã‚Šã¾ã›ã‚“ã€‚
            </textarea
        >
      </div>

      <!-- Output Section -->
      <div class="panel">
        <div class="panel-header">Analyzed Output</div>
        <div id="output-display"></div>
        <div class="status-bar" id="status-bar">Ready</div>
      </div>
    </div>

    <!-- 1. Load Sudachi (Assumes sudachi.js is in root or accessible) -->
    <script type="module">
      import { GrammarRule } from "./grammar-engine.js";
      import GRAMMAR_RULES from "./grammar-rules.js";
      import {
        SudachiStateless,
        TokenizeMode,
      } from "./sudachi-wasm/sudachi.js";

      const inputText = document.getElementById("input-text");
      const outputDisplay = document.getElementById("output-display");
      const statusBar = document.getElementById("status-bar");

      // --- App State ---
      const state = (window.state = {
        sudachi: null,
      });

      // --- Helpers: Dictionary & Parsing ---
      async function fetchAndGunzip(url) {
        const response = await fetch(url);
        if (!response.body) throw new Error("No response body");
        const ds = new DecompressionStream("gzip");
        const stream = response.body.pipeThrough(ds);
        return await new Response(stream).blob();
      }

      // --- Sudachi Handling ---
      async function initSudachi() {
        console.log("init sudachi");
        try {
          statusBar.innerText = "Downloading dictionary...";
          // Ensure this path matches your actual file structure
          let dictBlob = await fetchAndGunzip(
            "sudachi-wasm/resources/system.dic.gz",
          );
          const buffer = await dictBlob.arrayBuffer();
          const uint8Array = new Uint8Array(buffer);

          state.sudachi = new SudachiStateless();
          await state.sudachi.initialize_from_bytes(uint8Array);
          statusBar.innerText = "Dictionary loaded";
        } catch (err) {
          statusBar.innerText = "Dict error: " + err.message;
          console.error(err);
        }
      }

      // --- Helper: Map Byte Offsets to Char Indices ---
      function mapTokensToCharOffsets(tokens, text) {
        let charIndex = 0;
        let byteIndex = 0;
        let tokenIdx = 0;

        // Iterate through the text character by character
        while (charIndex < text.length && tokenIdx < tokens.length) {
          const token = tokens[tokenIdx];

          // If current byte position matches the token's start byte
          if (byteIndex === token.begin) {
            token.charStart = charIndex;
            token.charEnd = charIndex + token.surface.length;

            // Sudachi provides 'end' as byte offset.
            // We use the surface length to advance charIndex.
            // We assume token.surface matches text exactly at this position.

            // Optimization: Skip bytes corresponding to this token
            const tokenByteLen = token.end - token.begin;
            byteIndex += tokenByteLen;
            charIndex += token.surface.length;
            tokenIdx++;
            continue;
          }

          // If we haven't reached the token yet (e.g. whitespace skipped by Sudachi or multi-byte drift),
          // advance one character and calculate its byte size.
          const codePoint = text.codePointAt(charIndex);
          let charBytes = 1;
          if (codePoint > 0x7f) {
            if (codePoint <= 0x7ff) charBytes = 2;
            else if (codePoint <= 0xffff) charBytes = 3;
            else charBytes = 4;
          }

          byteIndex += charBytes;
          // Advance charIndex (1 or 2 if surrogate pair)
          charIndex += codePoint > 0xffff ? 2 : 1;
        }
      }

      // --- 2. Main Analysis Logic ---
      async function runAnalysis() {
        if (!state.sudachi) await initSudachi();
        if (!state.sudachi) return; // Still failed to load

        const lines = inputText.value.trim().split("ã€‚");
        outputDisplay.innerHTML = "";
        if (!lines.length) {
          return;
        }
        let uniqueRanges = 0;
        const startTime = performance.now();
        // console.log("lines", lines);
        for (const text of lines) {
          // A. Tokenize
          const rawJson = state.sudachi.tokenize_stringified(text, 0); // Mode A
          const tokens = JSON.parse(rawJson);

          // B. Fix Offsets (Bytes -> Chars)
          mapTokensToCharOffsets(tokens, text);

          // C. Scan with Grammar Engine
          let allMatches = [];

          for (const ruleJson of GRAMMAR_RULES) {
            let rule = new GrammarRule(ruleJson);
            let results = rule.scan(tokens);

            // Map token-based matches to character-based ranges
            let ranges = results
              .map((m) => {
                const startToken = tokens[m.index];
                const endToken = tokens[m.index + m.length - 1];

                // Safety check in case offset mapping failed
                if (typeof startToken.charStart === "undefined") return null;

                return {
                  start: startToken.charStart,
                  end: endToken.charEnd,
                  ruleId: m.ruleId,
                  title: m.title,
                  text: m.text,
                };
              })
              .filter((r) => r !== null);

            allMatches.push(...ranges);
          }

          // D. Filter Overlaps
          const rangeCount = resolveOverlaps(allMatches);
          // E. Render
          let html = renderHighlightedText(text, rangeCount);
          uniqueRanges += rangeCount.length;
          outputDisplay.innerHTML += html;
        }

        const duration = (performance.now() - startTime).toFixed(2);
        statusBar.textContent = `Found ${uniqueRanges} matches in ${duration}ms`;
      }

      // --- 3. Overlap Resolution Strategy ---
      function resolveOverlaps(ranges) {
        if (ranges.length === 0) return [];

        // 1. Sort by Start ASC, then Length DESC (Longest match preferred)
        ranges.sort((a, b) => {
          if (a.start !== b.start) return a.start - b.start;
          return b.end - b.start - (a.end - a.start);
        });

        const result = [];
        let lastEnd = -1;

        for (const r of ranges) {
          // If this match starts after (or exactly when) the last one ended
          if (r.start >= lastEnd) {
            result.push(r);
            lastEnd = r.end;
          }
        }
        return result;
      }

      // --- 4. HTML Rendering ---
      function renderHighlightedText(text, ranges) {
        let html = "";
        let cursor = 0;
        const esc = (s) =>
          s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        for (const r of ranges) {
          // Append text before the match
          if (r.start > cursor) {
            html += esc(text.substring(cursor, r.start));
          }

          // Append the highlighted match
          const matchText = text.substring(r.start, r.end);
          html += `<span class="grammar-match" data-rule="${r.title} (${r.ruleId})">${esc(matchText)}</span>`;

          cursor = r.end;
        }

        // Append remaining text
        if (cursor < text.length) {
          html += esc(text.substring(cursor));
        }
        return html;
      }

      // --- 5. Event Listeners ---
      let timeout;
      inputText.addEventListener("input", () => {
        clearTimeout(timeout);
        timeout = setTimeout(runAnalysis, 300);
      });

      // Initial run
      runAnalysis();
    </script>
  </body>
</html>
