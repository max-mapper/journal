<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Japanese Grammar Matcher Demo</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f9;
        color: #333;
      }

      h1 {
        color: #2c3e50;
        padding: 20px;
        margin: 0;
        text-align: center;
      }

      .container {
        display: flex;
        gap: 20px;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        height: 80vh; /* Default desktop height */
      }

      .panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden; /* Keeps header/footer contained */
        min-height: 0; /* Important for flex child scrolling */
      }

      .panel-header {
        padding: 15px;
        background: #eee;
        border-bottom: 1px solid #ddd;
        font-weight: bold;
      }

      textarea {
        flex: 1;
        border: none;
        padding: 15px;
        font-size: 18px;
        line-height: 1.6;
        resize: none;
        outline: none;
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
        min-height: 200px;
      }

      #output-display {
        flex: 1;
        padding: 15px;
        font-size: 18px;
        line-height: 1.6;
        overflow-y: auto;
        white-space: pre-wrap; /* Preserve newlines */
        font-family: "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
        min-height: 200px;
      }

      /* Grammar Highlight Styles */
      .grammar-match {
        background-color: #e3f2fd;
        border-bottom: 2px solid #2196f3;
        cursor: pointer;
        border-radius: 3px;
        transition: background 0.2s;
      }

      .grammar-match:hover {
        background-color: #bbdefb;
      }

      .grammar-match.active {
        background-color: #ffe0b2;
        border-bottom-color: #ff9800;
      }

      /* Floating Tooltip Styles */
      #grammar-tooltip {
        position: absolute;
        z-index: 1000; /* Sit on top of everything */
        background: white;
        color: #333;
        padding: 15px;
        border-radius: 6px;
        font-size: 14px;
        max-width: 300px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        display: none; /* Hidden by default */
        border: 1px solid #ddd;
        line-height: 1.4;
      }

      #grammar-tooltip.visible {
        display: block;
        /* animation: fadeIn 0.15s ease-out; */
      }

      #grammar-tooltip h3 {
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #2196f3;
      }

      #grammar-tooltip p {
        margin: 0 0 10px 0;
        color: #555;
      }

      #grammar-tooltip a {
        display: inline-block;
        background-color: #2c3e50;
        color: white;
        padding: 6px 12px;
        text-decoration: none;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
      }

      #grammar-tooltip a:hover {
        background-color: #34495e;
      }

      /* Little arrow for the tooltip (CSS Triangle) */
      #grammar-tooltip::before {
        content: "";
        position: absolute;
        bottom: 100%; /* Top of tooltip */
        left: 50%;
        margin-left: -8px;
        border-width: 8px;
        border-style: solid;
        border-color: transparent transparent white transparent;
      }

      /* Adjust arrow if tooltip is positioned above */
      #grammar-tooltip.position-top::before {
        bottom: auto;
        top: 100%;
        border-color: white transparent transparent transparent;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(5px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .status-bar {
        padding: 10px;
        background: #2c3e50;
        color: white;
        font-size: 14px;
      }

      /* Mobile Responsive Styles */
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
          height: auto;
          padding: 10px;
        }

        .panel {
          height: auto;
          max-height: none;
        }

        textarea {
          min-height: 150px;
        }

        #output-display {
          min-height: 200px;
          max-height: 400px; /* Allow scroll on mobile */
        }
      }
    </style>
  </head>
  <body>
    <h1>ğŸ‡¯ğŸ‡µ Grammar Analyzer</h1>

    <div class="container">
      <!-- Input Section -->
      <div class="panel">
        <div class="panel-header">Input Japanese Text</div>
        <textarea
          id="input-text"
          placeholder="ã“ã“ã«æ—¥æœ¬èªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."
        >
ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’å‹é”ã«ã‚ã’ã¾ã™ã€‚
æ˜æ—¥ã¯é›¨ãŒãµã‚‹ã¨æ€ã„ã¾ã™ã€‚
ãƒ‘ãƒ³ã‚’é£Ÿã¹ã¾ã—ãŸã€‚ãŠè…¹ãŒç©ºã„ãŸã‹ã‚‰ã§ã™ã€‚
ã‚¢ãƒ¡ãƒªã‚«ã‹ã‚‰æ¥ã¾ã—ãŸã€‚
ä½•äººãã‚‰ã„æ¥ã¾ã™ã‹ã€‚
å‹é”ãŒç§ã«ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’ãã‚Œã¾ã—ãŸã€‚
æ—¥æœ¬èªã®æ£®ã§åƒããŸã„ã§ã™ã€‚
ã“ã“ã®ãƒ‘ã‚½ã‚³ãƒ³ã¯å­¦ç”Ÿã ã‘ãŒä½¿ãˆã¾ã™ã€‚
å¤§å­¦ã«è¡Œãã¤ã‚‚ã‚Šã§ã™ã€‚
ã“ã‚Œã‹ã‚‰åœ°çƒã®æ¸©åº¦ãŒã ã‚“ã ã‚“é«˜ããªã£ã¦ã„ãã€‚
ä»Šã€æœã”ã¯ã‚“ã‚’é£Ÿã¹ã¦ã„ã¾ã™ã€‚
å…ˆç”Ÿã«èã„ã¦ãã ã•ã„ã€‚
ä»–ã®äººã‚’å‚·ã¤ã‘ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚
ä»•äº‹ã¯å¿™ã—ã„ã§ã™ã€‚ã§ã‚‚ã€æ¥½ã—ã„ã§ã™ã€‚
å¸°ã£ã¦ã‚‚ã„ã„ã§ã™ã‹ã€‚
ã“ã“ã«æ¥ã¦ãã ã•ã„ã€‚
å®¿é¡Œã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ã€‚
ã‚¸ãƒ¥ãƒ›ã•ã‚“ã¯éŸ“å›½äººã˜ã‚ƒãªã„ã§ã™ã‹ã€‚
å¤§äººã«ãªã‚Šã¾ã—ãŸã€‚
ã‚²ãƒ¼ãƒ ã‚’ã—ã¾ã—ã‚‡ã†ã€‚
ã‚«ãƒ•ã‚§ã«è¡Œãã¾ã—ã‚‡ã†ã‹ã€‚
ãƒ†ãƒ¬ãƒ“ã‚’è¦‹ã¾ã›ã‚“ã‹ã€‚
æˆæ¥­ã¯4æ™‚ã¾ã§ã§ã™ã€‚
ç§ã¯å‹é”ã«ã‚¸ãƒ¥ãƒ¼ã‚¹ã‚’ã‚‚ã‚‰ã„ã¾ã—ãŸã€‚
ãƒ†ã‚¹ãƒˆã®å‰ã«å‹‰å¼·ã—ã¾ã™ã€‚
æˆæ¥­ã®å¾Œã§å¸°ã‚Šã¾ã—ãŸã€‚
ã“ã®æ¼¢å­—ã®èª­ã¿æ–¹ã¯ä½•ã§ã™ã‹ã€‚
ãŸãã•ã‚“æœ¬ãŒã‚ã‚Šã¾ã™ã€‚
æœ9æ™‚ã«èµ·ãã¾ã—ãŸã€‚
æ˜ ç”»ã‚’è¦‹ã‚‹ã“ã¨ãŒå¥½ãã§ã™ã€‚
è¨€ã„é–“é•ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
å½¼ã¯å‹é”ã‚’ã†ã‚‰ãã‚‹ã“ã¨ã¯ãªã„ã€‚
çŒ«ã¨çŠ¬ãŒå¥½ãã ã€‚
ãŠèŒ¶ã¨æ°´ã¨ã€ã©ã¡ã‚‰ãŒã„ã„ã§ã™ã‹ã€‚
ãƒ•ã‚¡ãƒŸãƒªãƒ¼ãƒãƒ¼ãƒˆã¨ã„ã†ã‚³ãƒ³ãƒ“ãƒ‹ã‚’çŸ¥ã£ã¦ã„ã¾ã™ã‹ã€‚
ã‚¿ãƒ©ã¨è¨€ã„ã¾ã™ã€‚
7æ™‚ã«èµ·ãã¾ã™ã€‚
æ–°å®¿ã¯æ±äº¬ã«ã‚ã‚‹ã€‚
æ—¥æœ¬ã«åƒãã«æ¥ãŸã€‚
ã“ã‚Œã¯ãƒšãƒ³ã§ã™ã€‚
ã‚†ã‹ã•ã‚“ã¯å…ˆç”Ÿã§ã™ã€‚
ä»Šã‹ã‚‰ä¼‘æ†©ãŒå§‹ã¾ã‚Šã¾ã™ã€‚
æ˜¨æ—¥4æ™‚ã«å¸°ã‚Šã¾ã—ãŸã€‚
çŒ«ã¯ã‹ã‚ã„ã„ã€‚
ä»Šæ—¥å‹‰å¼·ã—ãŸã‚Šã€è²·ã„ç‰©ã‚’ã—ãŸã‚Šã—ã¾ã—ãŸã€‚
èª•ç”Ÿæ—¥ã¯ã„ã¤ã§ã™ã‹ã€‚
å›³æ›¸é¤¨ã§å‹‰å¼·ã—ã¾ã™ã€‚
ãƒœãƒ¼ãƒ«ã‚’è½ã¨ã—ãŸã€‚
æ–°å®¿ã¸è¡Œãã¾ã™ã€‚
èª°ãŒé–¢è¥¿å‡ºèº«ã§ã™ã‹ã€‚
å…„å¼Ÿã¨ã‚ˆãã‘ã‚“ã‹ã—ã¾ã™ã€‚
ã“ã‚Œã¯ç§ã®ãƒšãƒ³ã ã€‚
ç§ã‚‚å­¦ç”Ÿã§ã™ã€‚
ç‰›ä¹³ã‚„åµã‚’è²·ã„ã¾ã—ãŸã€‚
1æ™‚ã”ã‚ä¼šè­°ãŒã‚ã‚Šã¾ã™ã€‚
æ—¥æœ¬ã«å¥½ããªé£Ÿã¹ç‰©ãŒã‚ã¾ã‚Šãªã„ã€‚
é­šã¯ãœã‚“ãœã‚“å¥½ãã˜ã‚ƒãªã„ã€‚
æœ¬ã‚’3å†Šè²·ã„ã¾ã™ã€‚
ã“ã®ãƒšãƒ³ã¯é’ã„ã€‚
å®¶ã¯éƒµä¾¿å±€ã®å³ã«ã‚ã‚Šã¾ã™ã€‚
å½¼ã¯èƒŒãŒé«˜ã„ã§ã™ã€‚
æ­Œã†ã®ãŒå¥½ãã§ã™ã€‚
ä¸Šç”°ãã‚“ã¯å“çƒãŒä¸Šæ‰‹ã ã€‚
å»Šä¸‹ã‚’é™ã‹ã«æ­©ã„ãŸã€‚
æ—¥æœ¬ã¨ã‚¢ãƒ¡ãƒªã‚«ã¨ã€ã©ã¡ã‚‰ã®ã»ã†ãŒå¤§ãã„ï¼Ÿ
ã‚¢ãƒ¡ãƒªã‚«ã¯æ—¥æœ¬ã‚ˆã‚Šå¤§ãã„ã§ã™ã€‚
é£Ÿã¹ç‰©ã®ä¸­ã§ã€ãƒ‘ãƒ³ãŒä¸€ç•ªãŠã„ã—ã„ã§ã™ã€‚
æ˜æ—¥é›¨ãŒãµã‚‹ã§ã—ã‚‡ã†ã€‚
éƒ½ä¼šã¯ã†ã‚‹ã•ã™ãã‚‹ã€‚
ãŠé‡‘ãŒã»ã—ã„ã§ã™ã€‚
æ°´ã‚’ãã ã•ã„ã€‚
å®¶ã«å¸°ã£ã¦ã€ã‚·ãƒ£ãƒ¯ãƒ¼ã‚’æµ´ã³ã¾ã—ãŸã€‚
å­¦ç”Ÿã§ã€æ—¥æœ¬ã«ä½ã‚“ã§ã„ã‚‹ã€‚
ã¾ã å®¶ã‹ã‚‰å‡ºã¦ã„ãªã„ã§ã™ã€‚
å½¼ã¯ã‚‚ã†å¸°ã‚Šã¾ã—ãŸã€‚
å®¿é¡Œã‚’ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ã‚³ãƒ¼ãƒ’ãƒ¼ã˜ã‚ƒãªãã¦ãŠèŒ¶ã‚’ãã ã•ã„ã€‚
æ—¥æœ¬èªã‚’å‹‰å¼·ã™ã‚‹ã€‚
æ¯ãŒãã‚ŒãŸæ™‚è¨ˆã¯å¤ã„ã§ã™ã€‚
å†·è”µåº«ã«ä½•ã‚‚ãªã„ã§ã™ã€‚

é¶è‚‰ã¯ã‚ã¾ã‚Šå¥½ãã˜ã‚ƒãªã„ã€‚
ä»•äº‹ãŒçµ‚ã‚ã£ãŸã‚ã¨ã§ã€ã‚¸ãƒ ã«è¡Œãã€‚
ã‚ãªãŸãŒè¡Œã‘ã°ã€ç§ã‚‚è¡Œãã¾ã™ã€‚
é›¨ãŒé™ã‚‰ãªã„å ´åˆã¯æ³³ãã¾ã™ã€‚
äºŒäººã ã‘ã§å°‘ã—è©±ãŒã—ãŸã„ã€‚
é›¨ãŒé™ã‚Šã ã—ãŸã€‚
æš‡ã ã‹ã‚‰ã€ã‚²ãƒ¼ãƒ ã§ã‚‚ã—ã¾ã—ã‚‡ã†ã€‚
ã“ã®çŒ«ã¯èª°ã‚‚æ¬²ã—ãŒã‚‹äººãŒã„ãªã‹ã£ãŸã€‚
æ—¥æœ¬èªã‚’å‹‰å¼·ã—å§‹ã‚ã¦ã€ã‚‚ã†å››å¹´çµŒã£ãŸã€‚
ãã®èˆ¹ã¯æ²ˆã‚€ã¯ãšãŒãªã„ã€‚
é£Ÿã¹ç‰©ãŒå¿…è¦ã§ã™ã€‚
é£Ÿã¹ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ç¾å‘³ã—ã„æ™©ã”ã¯ã‚“ãŒæ¬²ã—ã„ã€‚
ã“ã®ã‚²ãƒ¼ãƒ ã¯é›£ã—ã„ã‚“ã˜ã‚ƒãªã„ã‹ã€‚
å½¼ãŒé©šãã‹ã©ã†ã‹ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚
æ¼«ç”»ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
å¯¿å¸ã®é£Ÿã¹æ–¹ã‚’æ•™ãˆã¦ãã‚Œã¾ã›ã‚“ã‹ã€‚
æœ‰åäººã˜ã‚ƒãªã„ã‹ã—ã‚‰ï¼Ÿ
å­ä¾›ã¿ãŸã„ã§ã™ã€‚
ãƒ†ãƒ¬ãƒ“ã‚’è¦‹ãªãŒã‚‰æ™©ã”ã¯ã‚“ã‚’é£Ÿã¹ã¾ã™ã€‚
å¯ãªã„ã§å‹‰å¼·ã‚’ã—ã¾ã™ã€‚
å‹‰å¼·ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
å­¦æ ¡ã«è¡Œã‹ãªãã¦ã‚‚ã„ã„ã€‚
æ—¥æœ¬èªã‚’ç¿’ã„ãŸã„ã®ãªã‚‰ã€ã“ã®æœ¬ãŒã„ã„ã§ã™ã‚ˆã€‚
ã¡ã‚‡ã£ã¨å¾…ã¡ãªã•ã„ã€‚
ãŠæ¯ã•ã‚“ãŒå¸°ã£ã¦ããŸã“ã¨ã«æ°—ãŒã¤ãã€‚
ã“ã®è³ªå•ã«ã¯ç­”ãˆã«ãã„ã§ã™ã€‚
è¨€èªã®ä¸­ã§æ—¥æœ¬èªãŒä¸€ç•ªé›£ã—ã„ã¨æ€ã„ã¾ã™ã€‚
ã”ã¯ã‚“ã‚’ä½œã‚‹ã®ã«ä¸€æ™‚é–“ã‹ã‹ã‚Šã¾ã™ã€‚
ã“ã®ä»•äº‹ã¯ç§ãŒã„ãŸã—ã¾ã™ã€‚
çš†ãŒå­ä¾›ã®ã‚ˆã†ã«å…ƒæ°—ã«æ­Œã„å§‹ã‚ãŸã€‚
ï¼•ãƒ¡ãƒ¼ãƒˆãƒ«ãŠãã«æœ¨ã‚’æ¤ãˆã¾ã—ãŸã€‚
ã‚¿ãƒã‚³ã‚’æ­¢ã‚ã‚‰ã‚Œãªã„ã€‚
å¦¹ãŒéƒ¨å±‹ã«ã„ãªã„ã‚‰ã—ã„ã€‚
ä»Šå¹´ã®æš‘ã•ã¯æ™®é€šã§ã¯ãªã„ã€‚
æ¯ã¯ç§ã«è‡ªåˆ†ã®éƒ¨å±‹ã‚’ç‰‡ä»˜ã‘ã•ã›ãŸã€‚
æ¯æ—¥æ¯ã«é‡èœã‚’é£Ÿã¹ã•ã›ã‚‰ã‚Œã‚‹ã€‚
ã•ã™ãŒã®å½¼ã‚‚å¦»ã«ã¯å‹ã¦ãªã‹ã£ãŸã€‚
ç®±ã®ä¸­ã«åµã¯ä¸€å€‹ã—ã‹æ®‹ã£ã¦ã„ãªã„ã€‚
æ—¥æœ¬ã«æ¥ãŸã°ã‹ã‚Šã§ã™ã€‚
å¦¹ã¯ãã®é¦¬ã«ä¹—ã‚ŠãŸãŒã£ã¦ã„ã‚‹ã€‚
å¯‚ã—ã‹ã£ãŸã‚‰é›»è©±ã‚’ãã ã•ã„ã€‚
å®¿é¡Œã‚’ã—ãŸã‚‰ã©ã†ã§ã™ã‹ã€‚
ã‚ãªãŸã®ã“ã¨ã‚’è©±ã—ã¦ãŸã¨ã“ã‚ã ã‚ˆã€‚
æ˜æ—¥äº‹å‹™æ‰€ã«è¡Œã£ã¦ã»ã—ã„ã€‚
ç§ã¯ä»Šã€å®¶ã§æ—¥æœ¬èªã‚’å‹‰å¼·ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã™ã€‚
ã“ã®ã‚µãƒ©ãƒ€ãŒã™ã”ãç¾å‘³ã—ã„ã‚ˆã€‚é£Ÿã¹ã¦ã¿ã¦ã€‚
é›¨ã§ã‚‚è¡Œãã¾ã—ã‚‡ã†ã€‚
ã“ã®æ–‡ç« ã¯é‡è¦ã§ã™ã€‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚
å›ã«ä¼šãˆã¦ã‚ˆã‹ã£ãŸã€‚
æ—¥æœ¬èªã¯æœ€ã‚‚é›£ã—ã„è¨€èªã ã¨è¨€ã‚ã‚Œã¦ã„ã‚‹ã€‚
ãã®è¾ºã‚Šã¯ã¨ã¦ã‚‚è³‘ã‚„ã‹ã ã¨èã„ãŸã€‚
ã“ã‚Œã‹ã‚‰ãƒ‘ãƒ³ã‚’ç„¼ãã¨ã“ã‚ã§ã™ã€‚
ä»•äº‹ã‚’ç¶šã‘ã‚‹ã®ã¯ç„¡ç†ã ã¨æ€ã†ã€‚
ä¸€æ—¥ä¸­é›¨ãŒé™ã‚Šç¶šãã€‚
å»ºç‰©ã®ä¸­ã¯ã„ã¤ã‚‚ã‚ˆã‚Šæš—ã‹ã£ãŸã€‚
ç§ã¯ç•™å­¦ã‚’ã™ã‚‹äºˆå®šã§ã™ã€‚
ï¼•å¹´é–“æ—¥æœ¬èªã‚’å‹‰å¼·ã—ã¦ã€æ—¥æœ¬èªãŒè©±ã›ã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚
ãã®ã“ã¨ã¯å…¨ç„¶çŸ¥ã‚Šã¾ã›ã‚“ã€‚
            </textarea
        >
      </div>

      <!-- Output Section -->
      <div class="panel">
        <div class="panel-header">Analyzed Output</div>
        <div id="output-display"></div>
        <div class="status-bar" id="status-bar">Ready</div>
      </div>
    </div>

    <!-- The Floating Tooltip Container -->
    <div id="grammar-tooltip"></div>

    <script type="module">
      import { GrammarRule } from "./grammar-engine.js";
      import GRAMMAR_RULES from "./grammar-rules.js";
      import {
        SudachiStateless,
        TokenizeMode,
      } from "./sudachi-wasm/sudachi.js";

      const inputText = document.getElementById("input-text");
      const outputDisplay = document.getElementById("output-display");
      const statusBar = document.getElementById("status-bar");
      const tooltip = document.getElementById("grammar-tooltip");

      // --- App State ---
      const state = (window.state = {
        sudachi: null,
      });

      // --- Helpers: Dictionary & Parsing ---
      async function fetchAndGunzip(url) {
        const response = await fetch(url);
        if (!response.body) throw new Error("No response body");
        const ds = new DecompressionStream("gzip");
        const stream = response.body.pipeThrough(ds);
        return await new Response(stream).blob();
      }

      async function initSudachi() {
        console.log("init sudachi");
        try {
          statusBar.innerText = "Downloading dictionary...";
          let dictBlob = await fetchAndGunzip(
            "sudachi-wasm/resources/system.dic.gz",
          );
          const buffer = await dictBlob.arrayBuffer();
          const uint8Array = new Uint8Array(buffer);

          state.sudachi = new SudachiStateless();
          await state.sudachi.initialize_from_bytes(uint8Array);
          statusBar.innerText = "Dictionary loaded";
        } catch (err) {
          statusBar.innerText = "Dict error: " + err.message;
          console.error(err);
        }
      }

      function mapTokensToCharOffsets(tokens, text) {
        let charIndex = 0;
        let byteIndex = 0;
        let tokenIdx = 0;

        while (charIndex < text.length && tokenIdx < tokens.length) {
          const token = tokens[tokenIdx];
          if (byteIndex === token.begin) {
            token.charStart = charIndex;
            token.charEnd = charIndex + token.surface.length;
            const tokenByteLen = token.end - token.begin;
            byteIndex += tokenByteLen;
            charIndex += token.surface.length;
            tokenIdx++;
            continue;
          }
          const codePoint = text.codePointAt(charIndex);
          let charBytes = 1;
          if (codePoint > 0x7f) {
            if (codePoint <= 0x7ff) charBytes = 2;
            else if (codePoint <= 0xffff) charBytes = 3;
            else charBytes = 4;
          }
          byteIndex += charBytes;
          charIndex += codePoint > 0xffff ? 2 : 1;
        }
      }

      // --- 2. Main Analysis Logic ---
      async function runAnalysis() {
        if (!state.sudachi) await initSudachi();
        if (!state.sudachi) return;

        const text = inputText.value;
        outputDisplay.innerHTML = "";

        // Clear any open tooltip when re-analyzing
        hideTooltip();

        let uniqueRanges = 0;
        const startTime = performance.now();

        // A. Tokenize
        const rawJson = state.sudachi.tokenize_stringified(text, 0);
        const tokens = JSON.parse(rawJson);

        // B. Fix Offsets
        mapTokensToCharOffsets(tokens, text);

        // C. Scan with Grammar Engine
        let allMatches = [];

        for (const ruleJson of GRAMMAR_RULES) {
          let rule = new GrammarRule(ruleJson);
          let results = rule.scan(tokens);

          let ranges = results
            .map((m) => {
              const startToken = tokens[m.index];
              const endToken = tokens[m.index + m.length - 1];
              if (typeof startToken.charStart === "undefined") return null;

              return {
                start: startToken.charStart,
                end: endToken.charEnd,
                ruleId: m.ruleId,
                // Extract detailed info from the rule definition
                title: ruleJson.title || "Grammar Rule",
                description:
                  ruleJson.description || "No description available.",
                link: ruleJson.link || "#",
              };
            })
            .filter((r) => r !== null);

          allMatches.push(...ranges);
        }
        // D. Filter Overlaps
        const rangeCount = resolveOverlaps(allMatches);
        // E. Render
        let html = renderHighlightedText(text, rangeCount);
        uniqueRanges += rangeCount.length;
        outputDisplay.innerHTML = html + (text.trim() ? "ã€‚" : "");

        const duration = (performance.now() - startTime).toFixed(2);
        statusBar.textContent = `Found ${uniqueRanges} matches in ${duration}ms`;
      }

      function resolveOverlaps(ranges) {
        if (ranges.length === 0) return [];
        ranges.sort((a, b) => {
          if (a.start !== b.start) return a.start - b.start;
          return b.end - b.start - (a.end - a.start);
        });

        const result = [];
        let lastEnd = -1;
        for (const r of ranges) {
          if (r.start >= lastEnd) {
            result.push(r);
            lastEnd = r.end;
          }
        }
        return result;
      }

      function renderHighlightedText(text, ranges) {
        let html = "";
        let cursor = 0;
        const esc = (s) =>
          s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        for (const r of ranges) {
          if (r.start > cursor) {
            html += esc(text.substring(cursor, r.start));
          }

          const matchText = text.substring(r.start, r.end);
          // Embed data attributes for the tooltip
          html += `<span class="grammar-match"
                        data-title="${esc(r.title)}"
                        data-desc="${esc(r.description)}"
                        data-link="${esc(r.link)}">${esc(matchText)}</span>`;

          cursor = r.end;
        }

        if (cursor < text.length) {
          html += esc(text.substring(cursor));
        }
        return html;
      }

      // --- Tooltip Logic ---

      let activeElement = null;

      function showTooltip(element) {
        const title = element.dataset.title;
        const desc = element.dataset.desc;
        const link = element.dataset.link;

        // Build HTML
        tooltip.innerHTML = `
          <h3>${title}</h3>
          <p>${desc}</p>
          ${link && link !== "#" ? `<a href="${link}" target="_blank" rel="noopener noreferrer">Check on Bunpro &rarr;</a>` : ""}
        `;

        // Calculate Position
        const rect = element.getBoundingClientRect();
        const scrollX = window.scrollX || window.pageXOffset;
        const scrollY = window.scrollY || window.pageYOffset;

        tooltip.classList.remove("visible", "position-top");
        tooltip.style.display = "block"; // make it block to calculate dimension

        // Default: Bottom Center
        let top = rect.bottom + scrollY + 10;
        let left = rect.left + scrollX + rect.width / 2;

        // Check collision with right edge of screen
        const tooltipWidth = 300; // max-width roughly
        if (left + tooltipWidth / 2 > window.innerWidth) {
          // shifting logic could go here, but CSS transform handles centering usually.
          // simple clamp:
          // left = Math.min(left, window.innerWidth - (tooltipWidth/2) - 10);
        }

        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;
        tooltip.style.transform = "translateX(-50%)"; // Center horizontally

        // If off screen bottom, flip to top?
        // (Simplified check)
        // if (top + tooltip.offsetHeight > document.body.offsetHeight) {
        //   top = rect.top + scrollY - tooltip.offsetHeight - 10;
        //   tooltip.classList.add('position-top');
        //   tooltip.style.top = `${top}px`;
        // }

        tooltip.classList.add("visible");

        // Highlight active word
        if (activeElement) activeElement.classList.remove("active");
        element.classList.add("active");
        activeElement = element;
      }

      function hideTooltip() {
        tooltip.classList.remove("visible");
        tooltip.style.display = "none";
        if (activeElement) {
          activeElement.classList.remove("active");
          activeElement = null;
        }
      }

      // Event Delegation
      document.addEventListener("click", (e) => {
        const match = e.target.closest(".grammar-match");
        const insideTooltip = e.target.closest("#grammar-tooltip");

        // 1. Clicked inside the tooltip (e.g. the link)
        if (insideTooltip) {
          return; // Do nothing, let link work
        }

        // 2. Clicked a grammar word
        if (match) {
          e.stopPropagation(); // prevent document click from closing it immediately

          if (activeElement === match) {
            // Toggle off if clicking the same one
            hideTooltip();
          } else {
            // Open new one
            showTooltip(match);
          }
          return;
        }

        // 3. Clicked anywhere else (background)
        hideTooltip();
      });

      // --- Event Listeners ---
      let timeout;
      inputText.addEventListener("input", () => {
        clearTimeout(timeout);
        timeout = setTimeout(runAnalysis, 300);
      });

      // Initial run
      runAnalysis();
    </script>
  </body>
</html>
