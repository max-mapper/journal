import * as mod from "./sqlhttp/index.js";
console.log(mod);
let createDbWorker = mod.default().createDbWorker;
// Configuration for loading the WASM and Worker from CDN
const workerUrl = new URL("./sqlhttp/sqlite.worker.js", import.meta.url);
const wasmUrl = new URL("./sqlhttp/sql-wasm.wasm", import.meta.url);

let dbWorker = null;

async function initDatabase() {
  if (dbWorker) return dbWorker;

  // Load the config generated by the splitter tool
  // ensure /public/db/config.json exists relative to this file
  dbWorker = await createDbWorker(
    [
      {
        from: "inline",
        config: {
          serverMode: "full", // file is just a plain old full sqlite database
          requestChunkSize: 4096, // the page size of the  sqlite database (by default 4096)
          url: "/jp-words/dictionary.db", // url to the database (relative or full)
        },
      },
    ],
    workerUrl.toString(),
    wasmUrl.toString(),
  );

  return dbWorker;
}

// UI Elements
const modal = document.getElementById("dictionary-modal");
const modalTitle = document.getElementById("modal-title");
const modalResults = document.getElementById("modal-results");
const closeBtn = document.querySelector(".close-btn");

// Close Modal Logic
closeBtn.onclick = () => modal.classList.add("hidden");
window.onclick = (event) => {
  if (event.target == modal) modal.classList.add("hidden");
};

// Handle Word Click
document.querySelectorAll(".word-btn").forEach((btn) => {
  btn.addEventListener("click", async (e) => {
    const word = e.target.dataset.word;
    openModal(word);
    await searchDictionary(word);
  });
});

function openModal(word) {
  modalTitle.textContent = `Searching for "${word}"...`;
  modalResults.innerHTML = '<p class="center">Querying database...</p>';
  modal.classList.remove("hidden");
}
// ... imports and initDatabase code ...

/**
 * Helper to execute SQL and normalize results to array of objects.
 * Mimics the behavior of the synchronous 'sqlite' function in your class.
 */
async function execQuery(worker, sql, params = []) {
  // sql.js-httpvfs exec returns an array of result sets (usually just one)
  const resultSets = await worker.db.exec(sql, params);

  if (!resultSets || resultSets.length === 0) return [];

  const { columns, values } = resultSets[0];
  return values.map((row) => {
    const obj = {};
    columns.forEach((col, index) => {
      obj[col] = row[index];
    });
    return obj;
  });
}

/**
 * simple check to see if string contains Japanese characters
 */
function isJapanese(term) {
  return /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/.test(
    term,
  );
}

async function searchDictionary(term) {
  try {
    const worker = await initDatabase();

    // 1. Determine Search Mode
    const japanese = isJapanese(term);
    const limit = 5; // Fixed limit for demo

    // 2. Fetch Entry IDs (Logic from PaginatedQuery.loadNext)
    // We replace :word and :limit parameters with ? for prepared statements
    let idResults;

    if (japanese) {
      const sql = `
                SELECT DISTINCT EntryId FROM Forms
                WHERE Form LIKE '%' || ? || '%' 
                ORDER BY EntryId
                LIMIT ?
            `;
      idResults = await execQuery(worker, sql, [term, limit]);
    } else {
      const sql = `
                SELECT DISTINCT EntryId FROM Subentries
                INNER JOIN (SELECT SubentryId as Id FROM Glosses WHERE Content LIKE '%' || ? || '%')
                WHERE Subentries.SubentryId = Id
                ORDER BY EntryId
                LIMIT ?
            `;
      idResults = await execQuery(worker, sql, [term, limit]);
    }

    const entries = [];

    // 3. Hydrate Data (Logic from PaginatedQuery loop)
    // We use Promise.all to fetch details for found IDs in parallel where possible
    for (const row of idResults) {
      const id = row.EntryId;

      // Fetch Forms
      const formsRaw = await execQuery(
        worker,
        `SELECT Form FROM Forms WHERE EntryId = ?`,
        [id],
      );
      const forms = formsRaw.map((r) => r.Form);

      // Fetch Readings
      const readingsRaw = await execQuery(
        worker,
        `SELECT Reading FROM Readings WHERE EntryId = ?`,
        [id],
      );
      const readings = readingsRaw.map((r) => r.Reading);

      // Fetch Subentries (Deep nested fetch)
      const subentriesRaw = await execQuery(
        worker,
        `SELECT SubentryId, PartOfSpeech, SourceCitationId FROM Subentries WHERE EntryId = ?`,
        [id],
      );

      // We must map async to get citations and glosses for each subentry
      const subentries = await Promise.all(
        subentriesRaw.map(async (subRow) => {
          // Get Citation
          // Note: using [0] safely or fallback
          const citationRaw = await execQuery(
            worker,
            `SELECT Name, Description FROM Citations WHERE CitationId = ?`,
            [subRow.SourceCitationId],
          );
          const citation = citationRaw.length > 0 ? citationRaw[0].Name : "";

          // Get Glosses
          const glossesRaw = await execQuery(
            worker,
            `SELECT Content FROM Glosses WHERE SubentryId = ?`,
            [subRow.SubentryId],
          );
          const glosses = glossesRaw.map((g) => ({ content: g.Content }));

          return {
            part_of_speech: subRow.PartOfSpeech,
            citation: citation,
            glosses: glosses,
          };
        }),
      );

      entries.push({
        forms,
        readings,
        subentries,
      });
    }

    renderResults(entries);
  } catch (err) {
    console.error(err);
    modalResults.innerHTML = `<p style="color:red">Error: ${err.message}</p>`;
  }
}

/**
 * Updated render function to handle the nested object structure
 * returned by the new logic.
 */
function renderResults(entries) {
  modalTitle.textContent = `Results`;
  modalResults.innerHTML = "";

  if (!entries || entries.length === 0) {
    modalResults.innerHTML = "<p>No results found.</p>";
    return;
  }

  entries.forEach((entry) => {
    const entryDiv = document.createElement("div");
    entryDiv.className = "entry";

    // Join forms and readings
    const title = entry.forms.join(", ");
    const subtitle = entry.readings.length
      ? `(${entry.readings.join(", ")})`
      : "";

    let html = `<h3>${title} <span style="font-weight:normal; font-size: 0.9em">${subtitle}</span></h3>`;

    // Render subentries (Meanings)
    entry.subentries.forEach((sub) => {
      html += `
                <div style="margin-top: 0.5em; padding-left: 0.5em; border-left: 2px solid #eee;">
                    <div class="part-of-speech">${sub.part_of_speech || "Definition"}</div>
                    <ul class="gloss-list">
                        ${sub.glosses.map((g) => `<li>${g.content}</li>`).join("")}
                    </ul>
                    ${sub.citation ? `<cite>Source: ${sub.citation}</cite>` : ""}
                </div>
            `;
    });

    entryDiv.innerHTML = html;
    modalResults.appendChild(entryDiv);
  });
}
